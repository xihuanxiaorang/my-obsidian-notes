---
tags:
  - LeetCode
  - Algorithm
level: EASY
categories:
  - 数组
  - 哈希表
create_time: 2025/08/16 22:18
update_time: 2025/08/30 18:56
---

## 题目描述

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

**示例 1：**

```text
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```text
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```text
输入：nums = [3,3], target = 6
输出：[0,1]
```

**提示：**

- `2 <= nums.length <= 10^4`
- `-10^9 <= nums[i] <= 10^9`
- `-10^9 <= target <= 10^9`
- **只会存在一个有效答案**

**进阶：**
你可以想出一个时间复杂度小于 `O(n^2)` 的算法吗？

## 解法

### 方法一：暴力枚举

#### 解题思路

前提：题目保证每种输入只有唯一解，并且不能重复使用同一元素。

最直观的方法是枚举数组中的每个元素 `x`，然后在其后面的元素中查找是否存在 `target - x`。需要注意的是，已经遍历过的元素不再参与匹配。

#### 代码实现

```java
class Solution {  
  /**  
   * 返回数组中和为目标值的两个数的索引。  
   *  
   * @param {int[]} nums - 整数数组  
   * @param {int}   target - 目标和  
   * @return {int[]} 两个数的索引，如果找不到则返回空数组  
   */  
  public int[] twoSum(int[] nums, int target) {  
    // 遍历数组中的每个元素  
    for (int i = 0; i < nums.length; i++) {  
      // 从当前元素的下一个元素开始遍历  
      for (int j = i + 1; j < nums.length; j++) {  
        // 检查当前元素和下一个元素的和是否等于目标值  
        if (nums[i] + nums[j] == target) {  
          // 如果找到，返回这两个元素的索引  
          return new int[]{i, j};  
        }  
      }  
    }  
    // 如果没有找到满足条件的两个元素，返回空数组  
    return new int[0];  
  }  
}
```

时间复杂度：$O(N^2)$，其中 $N$ 是数组中的元素数量。

空间复杂度：$O(1)$。

### 方法二：哈希表

#### 解题思路

方法一的时间复杂度较高，因为每次都要遍历剩余元素查找 `target - x`，这导致了 $O(N^2)$ 的时间复杂度。为了提高效率，我们可以利用哈希表来快速查找目标差值。

通过使用哈希表，在遍历数组的过程中，可以在常数时间内检查 `target - x` 是否存在。这大大减少了查找时间，使得时间复杂度从 $O(N^2)$ 降低到 $O(N)$。

具体思路如下：
1. 遍历数组的每个元素 `x`。
2. 在哈希表中检查 `target - x` 是否已出现。如果出现，说明找到了两个数，返回它们的索引。
3. 如果未找到，将当前元素及其索引存入哈希表，继续遍历下一个元素。

#### 代码实现

```java
class Solution {  
  /**  
   * 返回数组中和为目标值的两个数的索引。  
   *  
   * @param {int[]} nums - 整数数组  
   * @param {int}   target - 目标和  
   * @return {int[]} 两个数的索引，如果找不到则返回空数组  
   */  
  public int[] twoSum(int[] nums, int target) {  
    // 创建一个哈希表来存储每个元素及其对应的索引  
    final Map<Integer, Integer> table = new HashMap<>();  
    // 遍历数组中的每个元素  
    for (int i = 0; i < nums.length; i++) {  
      // 检查目标值减去当前元素的结果是否在哈希表中  
      if (table.containsKey(target - nums[i])) {  
        // 如果找到，则返回这两个元素的索引  
        return new int[]{table.get(target - nums[i]), i};  
      }  
      // 将当前元素及其索引存入哈希表  
      table.put(nums[i], i);  
    }  
    // 如果没有找到满足条件的两个元素，返回空数组  
    return new int[0];  
  }  
}
```

时间复杂度：$O(N)$，其中 $N$ 是数组中的元素数量。

空间复杂度：$O(N)$，需要额外的哈希表来存储数组元素及其对应的索引，其中 $N$ 是数组中的元素数量。
