---
tags:
  - LeetCode
  - Algorithm
level: MEDIUM
categories:
  - 链表
create_time: 2025/08/16 22:18
update_time: 2025/08/24 21:30
---

## 题目描述

你可以选择使用单链表或者双链表，设计并实现自己的链表。

单链表中的节点应该具备两个属性：`val` 和 `next`。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。

如果是双向链表，则还需要属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点下标从 **0** 开始。

实现 `MyLinkedList` 类：

- `MyLinkedList()` 初始化 `MyLinkedList` 对象。
- `int get(int index)` 获取链表中下标为 `index` 的节点的值。如果下标无效，则返回 `-1`。
- `void addAtHead(int val)` 将一个值为 `val` 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
- `void addAtTail(int val)` 将一个值为 `val` 的节点追加到链表中作为链表的最后一个元素。
- `void addAtIndex(int index, int val)` 将一个值为 `val` 的节点插入到链表中下标为 `index` 的节点之前。如果 `index` 等于链表的长度，那么该节点会被追加到链表的末尾。如果 `index` 比长度更大，该节点将 **不会插入** 到链表中。
- `void deleteAtIndex(int index)` 如果下标有效，则删除链表中下标为 `index` 的节点。

**示例：**

```text
输入
["MyLinkedList", "addAtHead", "addAtTail", "addAtIndex", "get", "deleteAtIndex", "get"]
[[], [1], [3], [1, 2], [1], [1], [1]]

输出
[null, null, null, null, 2, null, 3]

解释
MyLinkedList myLinkedList = new MyLinkedList();
myLinkedList.addAtHead(1);
myLinkedList.addAtTail(3);
myLinkedList.addAtIndex(1, 2);    // 链表变为 1->2->3
myLinkedList.get(1);              // 返回 2
myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1->3
myLinkedList.get(1);              // 返回 3
```

**提示：**

- `0 <= index, val <= 1000`
- 请不要使用内置的 `LinkedList` 库。
- 调用 `get`、`addAtHead`、`addAtTail`、`addAtIndex` 和 `deleteAtIndex` 的次数不超过 `2000`。

## 解法

### 方法一：单向链表 + 虚拟头节点

#### 解题思路

##### 设计

- 节点 [[#^bcf48d|ListNode]]：链表中的基本单元，由数据域 `val` 和后继指针 `next` 组成。
- 链表 [[#^0c713f|MyLinkedList]]：
	- 虚拟头节点 `dummyHead`：在链表头部引入一个不存储有效数据的哨兵（sentinel）节点，作为统一的起点，避免在插入或删除首节点时的额外边界处理，使逻辑更简洁一致。
	- 节点计数 `size`：维护链表的实际元素数量（不含虚拟头节点），便于快速校验索引合法性，提升操作的可靠性和效率。

![[单向链表数据结构（虚拟头节点）|800]]

```java
private class ListNode {
  // 节点存储的值
  private int val;
  // 后继指针
  private ListNode next;

  public ListNode() {
  }

  public ListNode(final int val) {
    this.val = val;
  }

  public ListNode(final int val, final ListNode next) {
    this.val = val;
    this.next = next;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder("[");
    for (ListNode curr = this; curr != null; curr = curr.next) {
      sb.append(curr.val);
      if (curr.next != null) sb.append(", ");
    }
    return sb.append("]").toString();
  }
}
```

^bcf48d

```java
class MyLinkedList {
  // 虚拟头节点（不存储有效数据）
  private ListNode dummyHead;
  // 链表元素个数（不含虚拟头节点）
  private int size;

  public MyLinkedList() {
    dummyHead = new ListNode(-1);
  }
}
```

^0c713f

##### 获取指定位置节点的值

```java
public int get(int index) {
  // 1. 校验索引范围：若 index < 0 或 index >= size，说明越界
  if (index < 0 || index >= size) return -1;
  // 2. 从虚拟头节点开始遍历，移动 index+1 次到达目标节点
  ListNode curr = dummyHead;
  for (int i = 0; i <= index; i++) {
    curr = curr.next;
  }
  // 3. 返回目标节点的值
  return curr.val;
}
```

##### 在指定位置前插入节点

![[单向链表-插入节点|800]]

```java hl:22
public void addAtIndex(int index, int val) {
  // 1. 校验索引范围：若 index < 0 或 index > size，说明越界
  if (index < 0 || index > size) return;
  // 2. 从虚拟头节点开始遍历，找到插入位置的前驱节点
  ListNode prev = dummyHead;
  for (int i = 0; i < index; i++) prev = prev.next;
  // 3. 创建新节点并插入：新节点指向前驱节点的后继节点，再让前驱节点指向新节点
  prev.next = new ListNode(val, prev.next);
  // 4. 更新链表长度
  size++;
}
```

在头部插入节点 `addAtHead` 和在尾部插入节点 `addAtTail`，都可以复用 `addAtIndex` 方法来实现：

```java hl:2,6
public void addAtHead(int val) {  
  addAtIndex(0, val);  
}  

public void addAtTail(int val) {  
  addAtIndex(size, val);  
}
```

##### 删除指定位置节点

![[单向链表-删除节点|800]]

```java hl:8
public void deleteAtIndex(int index) {  
  // 1. 校验索引范围：若 index < 0 或 index >= size，说明越界  
  if (index < 0 || index >= size) return;  
  // 2. 从虚拟头节点开始遍历，找到目标节点的前驱节点  
  ListNode prev = dummyHead;  
  for (int i = 0; i < index; i++) prev = prev.next;  
  // 3. 跳过目标节点，实现删除  
  prev.next = prev.next.next;  
  // 4. 更新链表长度  
  size--;  
}
```

#### 完整代码实现

```java
class MyLinkedList {  
  // 虚拟头节点（不存储有效数据）  
  private ListNode dummyHead;  
  // 链表元素个数（不含虚拟头节点）  
  private int size;  

  public MyLinkedList() {  
    dummyHead = new ListNode(-1);  
  }  

  /**  
   * 获取链表中指定索引位置的节点值  
   *  
   * @param index 目标索引（0 <= index < size）  
   * @return 如果索引合法，返回对应节点的值；否则返回 -1  
   */  
  public int get(int index) {  
    // 1. 校验索引范围：若 index < 0 或 index >= size，说明越界  
    if (index < 0 || index >= size) return -1;  
    // 2. 从虚拟头节点开始遍历，移动 index+1 次到达目标节点  
    ListNode curr = dummyHead;  
    for (int i = 0; i <= index; i++) {  
      curr = curr.next;  
    }  
    // 3. 返回目标节点的值  
    return curr.val;  
  }  

  /**  
   * 在链表头部插入一个新节点  
   *  
   * @param val 新节点的值  
   */  
  public void addAtHead(int val) {  
    addAtIndex(0, val);  
  }  

  /**  
   * 在链表尾部插入一个新节点  
   *  
   * @param val 新节点的值  
   */  
  public void addAtTail(int val) {  
    addAtIndex(size, val);  
  }  

  /**  
   * 在链表指定位置前插入一个新节点  
   *  
   * @param index 插入位置索引，范围 [0, size]  
   * @param val   新节点的值  
   * @return 无返回值  
   *  
   * <p>说明：  
   * <ul>  
   *   <li>{@code index = 0}     → 在头部插入；</li>  
   *   <li>{@code index = size}  → 在尾部插入；</li>  
   *   <li>{@code index < 0} 或 {@code index > size} → 操作无效，直接返回。</li>  
   * </ul>  
   */  
  public void addAtIndex(int index, int val) {  
    // 1. 校验索引范围：若 index < 0 或 index > size，说明越界  
    if (index < 0 || index > size) return;  
    // 2. 从虚拟头节点开始遍历，找到插入位置的前驱节点  
    ListNode prev = dummyHead;  
    for (int i = 0; i < index; i++) prev = prev.next;  
    // 3. 创建新节点并插入：新节点指向前驱节点的后继节点，再让前驱节点指向新节点  
    prev.next = new ListNode(val, prev.next);  
    // 4. 更新链表长度  
    size++;  
  }  

  /**  
   * 删除链表中指定索引位置的节点  
   *  
   * @param index 要删除的节点索引，范围 [0, size - 1]  
   * @return 无返回值  
   *  
   * <p>说明：  
   * <ul>  
   *   <li>{@code index = 0}     → 删除头节点；</li>  
   *   <li>{@code 0 < index < size} → 删除中间节点；</li>  
   *   <li>{@code index = size - 1} → 删除尾节点；</li>  
   *   <li>{@code index < 0} 或 {@code index >= size} → 操作无效，直接返回。</li>  
   * </ul>  
   */  
  public void deleteAtIndex(int index) {  
    // 1. 校验索引范围：若 index < 0 或 index >= size，说明越界  
    if (index < 0 || index >= size) return;  
    // 2. 从虚拟头节点开始遍历，找到目标节点的前驱节点  
    ListNode prev = dummyHead;  
    for (int i = 0; i < index; i++) prev = prev.next;  
    // 3. 跳过目标节点，实现删除  
    prev.next = prev.next.next;  
    // 4. 更新链表长度  
    size--;  
  }  

  @Override  
  public String toString() {  
    StringBuilder sb = new StringBuilder("[");  
    for (ListNode curr = dummyHead.next; curr != null; curr = curr.next) {  
      sb.append(curr.val);  
      if (curr.next != null) sb.append(", ");  
    }  
    return sb.append("]").toString();  
  }  

  private class ListNode {  
    // 节点存储的值  
    private int val;  
    // 后继指针
    private ListNode next;  

    public ListNode() {  
    }  

    public ListNode(final int val) {  
      this.val = val;  
    }  

    public ListNode(final int val, final ListNode next) {  
      this.val = val;  
      this.next = next;  
    }  

    @Override  
    public String toString() {  
      StringBuilder sb = new StringBuilder("[");  
      for (ListNode curr = this; curr != null; curr = curr.next) {  
        sb.append(curr.val);  
        if (curr.next != null) sb.append(", ");  
      }  
      return sb.append("]").toString();  
    }  
  }  
}
```

> [!example]- 单向链表（不使用虚拟头节点）
>
> ```java
> class MyLinkedList {
>   private ListNode head;
>   private int size;
> 
>   public MyLinkedList() {
> 
>   }
> 
>   public int get(int index) {
>     if (index < 0 || index >= size) return -1;
>     return node(index).val;
>   }
> 
>   public void addAtHead(int val) {
>     addAtIndex(0, val);
>   }
> 
>   public void addAtTail(int val) {
>     addAtIndex(size, val);
>   }
> 
>   public void addAtIndex(int index, int val) {
>     if (index < 0 || index > size) return;
>     if (index == 0) head = new ListNode(val, head);
>     else {
>       ListNode prev = node(index - 1);
>       prev.next = new ListNode(val, prev.next);
>     }
>     size++;
>   }
> 
>   public void deleteAtIndex(int index) {
>     if (index < 0 || index >= size) return;
>     if (index == 0) head = head.next;
>     else {
>       ListNode prev = node(index - 1);
>       prev.next = prev.next.next;
>     }
>     size--;
>   }
> 
>   private ListNode node(int index) {
>     if (index < 0 || index >= size) throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
>     ListNode curr = head;
>     for (int i = 0; i < index; i++) curr = curr.next;
>     return curr;
>   }
> 
>   @Override
>   public String toString() {
>     StringBuilder sb = new StringBuilder("[");
>     for (ListNode curr = head; curr != null; curr = curr.next) {
>       sb.append(curr.val);
>       if (curr.next != null) sb.append(", ");
>     }
>     return sb.append("]").toString();
>   }
> 
>   private class ListNode {
>     private int val;
>     private ListNode next;
> 
>     public ListNode() {
>     }
> 
>     public ListNode(final int val) {
>       this.val = val;
>     }
> 
>     public ListNode(final int val, final ListNode next) {
>       this.val = val;
>       this.next = next;
>     }
> 
>     @Override
>     public String toString() {
>       StringBuilder sb = new StringBuilder();
>       sb.append("[");
>       ListNode curr = this;
>       for (; ; ) {
>         sb.append(curr.val);
>         if (curr.next == null) {
>           return sb.append("]").toString();
>         }
>         curr = curr.next;
>         sb.append(",").append(" ");
>       }
>     }
>   }
> }
> ```

### 方法二：双向链表 + 虚拟头尾节点

#### 解题思路

##### 设计

- 节点 [[#^73a231|ListNode]]：链表的基本单元，由数据域 `val`、前驱指针 `prev` 和后继指针 `next` 组成，支持双向遍历。
- 链表 [[#^ed89b9|MyLinkedList]]：
	- 虚拟头节点 `dummyHead`：位于链表起始位置，不存储有效数据，用于统一处理插入和删除首节点的逻辑，避免边界特殊情况。
	- 虚拟尾节点 `dummyTail`：位于链表末尾，不存储有效数据，用于统一处理插入和删除尾节点的逻辑，简化实现。
	- 节点计数 `size`：维护链表的实际元素数量（不含虚拟头尾节点），便于快速校验索引合法性，提升操作的可靠性和效率。

![[双向链表数据结构（虚拟头尾节点）|1000]]

```java
private class ListNode {  
  // 节点存储的值  
  private int val;  
  // 前驱指针  
  private ListNode prev;  
  // 后继指针  
  private ListNode next;  
  
  public ListNode() {  
  }  
  
  public ListNode(final int val) {  
    this.val = val;  
  }  
  
  public ListNode(final ListNode prev, final int val, final ListNode next) {  
    this.val = val;  
    this.prev = prev;  
    this.next = next;  
  }  
  
  @Override  
  public String toString() {  
    StringBuilder sb = new StringBuilder("[");  
    for (ListNode curr = this; curr != null; curr = curr.next) {  
      sb.append(curr.val);  
      if (curr.next != null) sb.append(", ");  
    }  
    return sb.append("]").toString();  
  }  
}
```

^73a231

```java
class MyLinkedList {  
  // 虚拟头节点（不存储有效数据）  
  private ListNode dummyHead;  
  // 虚拟尾节点（不存储有效数据）  
  private ListNode dummyTail;  
  // 链表元素个数（不含虚拟头尾节点）  
  private int size;  
  
  public MyLinkedList() {  
    dummyHead = new ListNode(-1);  
    dummyTail = new ListNode(-1);  
    dummyHead.next = dummyTail;  
    dummyTail.prev = dummyHead;  
  }
}
```

^ed89b9

##### 获取指定位置节点的值

```java
/**  
 * 获取链表中指定索引位置的节点值  
 *  
 * @param index 目标索引（0 <= index < size）  
 * @return 如果索引合法，返回对应节点的值；否则返回 -1  
 */
public int get(int index) {  
  // 1. 校验索引范围：若 index < 0 或 index >= size，说明越界  
  if (index < 0 || index >= size) return -1;  
  // 2. 定位到指定索引位置的节点并返回节点存储的值
  return node(index).val;  
}

/**  
 * 根据索引定位节点  
 *  
 * <p> 若 index < size / 2，则从头节点 dummyHead 开始向右遍历，否则从尾节点 dummyTail 开始向左遍历。</p>  
 *  
 * @param index 节点索引（0 <= index < size）  
 * @return 对应位置的节点  
 * @throws IndexOutOfBoundsException 如果 index 越界  
 */  
private ListNode node(int index) {  
  // 检查索引是否越界  
  if (index < 0 || index >= size) {  
    throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);  
  }  
  // 如果索引小于链表长度的一半，则从头节点开始向右遍历  
  if (index < (size >> 1)) {  
    ListNode curr = dummyHead;  
    for (int i = 0; i <= index; i++) {  
      // 向右移动到下一个节点  
      curr = curr.next;  
    }  
    return curr;  
  } else {  
    // 否则从尾节点开始向左遍历  
    ListNode curr = dummyTail;  
    for (int i = size - 1; i >= index; i--) {  
      // 向左移动到前一个节点  
      curr = curr.prev;  
    }  
    return curr;  
  }  
}
```

##### 在指定位置前插入节点

![[双向链表-在指定位置前插入节点|800]]

```java
/**  
 * 在链表指定位置前插入一个新节点  
 *  
 * @param index 插入位置索引，范围 [0, size]  
 * @param val   新节点的值  
 * @return 无返回值  
 *  
 * <p>说明：  
 * <ul>  
 *   <li>{@code index = 0}     → 在头部插入；</li>  
 *   <li>{@code index = size}  → 在尾部插入；</li>  
 *   <li>{@code index < 0} 或 {@code index > size} → 操作无效，直接返回。</li>  
 * </ul>  
 */  
public void addAtIndex(int index, int val) {  
  // 1. 校验索引范围：若 index 不在 [0, size] 之间，直接返回，不做任何操作  
  if (index < 0 || index > size) return;  
  // 2. 确定插入位置的前驱节点 pred：  
  // 若 index == size，说明在链表尾部插入，新节点的前驱节点应是 dummyTail.prev  
  // 否则，找到目标位置的节点，再取它的前驱节点作为 pred  
  ListNode pred = index == size ? dummyTail.prev : node(index).prev;  
  // 3. 确定插入位置的后继节点 succ，即 pred 的后继节点  
  ListNode succ = pred.next;  
  // 4. 创建新节点并建立前驱、后继指针关系  
  ListNode newNode = new ListNode(pred, val, succ);  
  succ.prev = newNode;  
  pred.next = newNode;  
  // 5. 更新链表长度  
  size++;  
}
```

在头部插入节点 `addAtHead` 和在尾部插入节点 `addAtTail`，都可以复用 `addAtIndex` 方法来实现：

```java hl:2,6
public void addAtHead(int val) {  
  addAtIndex(0, val);  
}

public void addAtTail(int val) {  
  addAtIndex(size, val);  
}
```

##### 删除指定位置节点

![[双向链表-删除指定位置节点|800]]

```java
/**  
 * 删除链表中指定索引位置的节点  
 *  
 * @param index 要删除的节点索引，范围 [0, size - 1]  
 * @return 无返回值  
 *  
 * <p>说明：  
 * <ul>  
 *   <li>{@code index = 0}     → 删除头节点；</li>  
 *   <li>{@code 0 < index < size} → 删除中间节点；</li>  
 *   <li>{@code index = size - 1} → 删除尾节点；</li>  
 *   <li>{@code index < 0} 或 {@code index >= size} → 操作无效，直接返回。</li>  
 * </ul>  
 */  
public void deleteAtIndex(int index) {  
  // 1. 校验索引范围：若 index 不在 [0, size-1] 之间，直接返回  
  if (index < 0 || index >= size) return;  
  // 2. 找到要删除的目标节点 curr  
  ListNode curr = node(index);  
  // 3. 断开 curr 节点与前驱、后继的连接  
  // 前驱节点的 next 指向 curr 的后继  
  // 后继节点的 prev 指向 curr 的前驱  
  curr.prev.next = curr.next;  
  curr.next.prev = curr.prev;  
  // 4. 释放 curr 的前后指针，帮助 GC  
  curr.prev = null;  
  curr.next = null;  
  // 5. 更新链表长度  
  size--;  
}
```

#### 完整代码实现

```java
class MyLinkedList {  
  // 虚拟头节点（不存储有效数据）  
  private ListNode dummyHead;  
  // 虚拟尾节点（不存储有效数据）  
  private ListNode dummyTail;  
  // 链表元素个数（不含虚拟头尾节点）  
  private int size;  

  public MyLinkedList() {  
    dummyHead = new ListNode(-1);  
    dummyTail = new ListNode(-1);  
    dummyHead.next = dummyTail;  
    dummyTail.prev = dummyHead;  
  }  

  /**  
   * 获取链表中指定索引位置的节点值  
   *  
   * @param index 目标索引（0 <= index < size）  
   * @return 如果索引合法，返回对应节点的值；否则返回 -1  
   */  
  public int get(int index) {  
     // 1. 校验索引范围：若 index < 0 或 index >= size，说明越界  
     if (index < 0 || index >= size) return -1;  
     return node(index).val;  
   }  

  /**  
   * 在链表头部插入一个新节点  
   *  
   * @param val 新节点的值  
   */  
  public void addAtHead(int val) {  
    addAtIndex(0, val);  
  }  

  /**  
   * 在链表尾部插入一个新节点  
   *  
   * @param val 新节点的值  
   */  
  public void addAtTail(int val) {  
    addAtIndex(size, val);  
  }  

  /**  
   * 在链表指定位置前插入一个新节点  
   *  
   * @param index 插入位置索引，范围 [0, size]  
   * @param val   新节点的值  
   * @return 无返回值  
   *  
   * <p>说明：  
   * <ul>  
   *   <li>{@code index = 0}     → 在头部插入；</li>  
   *   <li>{@code index = size}  → 在尾部插入；</li>  
   *   <li>{@code index < 0} 或 {@code index > size} → 操作无效，直接返回。</li>  
   * </ul>  
   */  
  public void addAtIndex(int index, int val) {  
    // 1. 校验索引范围：若 index 不在 [0, size] 之间，直接返回，不做任何操作  
    if (index < 0 || index > size) return;  
    // 2. 确定插入位置的前驱节点 pred：  
    // 若 index == size，说明在链表尾部插入，新节点的前驱节点应是 dummyTail.prev    
    // 否则，找到目标位置的节点，再取它的前驱节点作为 pred    
    ListNode pred = index == size ? dummyTail.prev : node(index).prev;  
    // 3. 确定插入位置的后继节点 succ，即 pred 的后继节点  
    ListNode succ = pred.next;  
    // 4. 创建新节点并建立前驱、后继指针关系  
    ListNode newNode = new ListNode(pred, val, succ);  
    succ.prev = newNode;  
    pred.next = newNode;  
    // 5. 更新链表长度  
    size++;  
  }  

  /**  
   * 删除链表中指定索引位置的节点  
   *  
   * @param index 要删除的节点索引，范围 [0, size - 1]  
   * @return 无返回值  
   *  
   * <p>说明：  
   * <ul>  
   *   <li>{@code index = 0}     → 删除头节点；</li>  
   *   <li>{@code 0 < index < size} → 删除中间节点；</li>  
   *   <li>{@code index = size - 1} → 删除尾节点；</li>  
   *   <li>{@code index < 0} 或 {@code index >= size} → 操作无效，直接返回。</li>  
   * </ul>  
   */  
  public void deleteAtIndex(int index) {  
    // 1. 校验索引范围：若 index 不在 [0, size-1] 之间，直接返回  
    if (index < 0 || index >= size) return;  
    // 2. 找到要删除的目标节点 curr    
    ListNode curr = node(index);  
    // 3. 断开 curr 节点与前驱、后继的连接  
    // 前驱节点的 next 指向 curr 的后继  
    // 后继节点的 prev 指向 curr 的前驱  
    curr.prev.next = curr.next;  
    curr.next.prev = curr.prev;  
    // 4. 释放 curr 的前后指针，帮助 GC    
    curr.prev = null;  
    curr.next = null;  
    // 5. 更新链表长度  
    size--;  
  }  

  /**  
   * 根据索引定位节点  
   *  
   * <p> 若 index < size / 2，则从头节点 dummyHead 开始向右遍历，否则从尾节点 dummyTail 开始向左遍历。</p>  
   *  
   * @param index 节点索引（0 <= index < size）  
   * @return 对应位置的节点  
   * @throws IndexOutOfBoundsException 如果 index 越界  
   */  
  private ListNode node(int index) {  
    // 检查索引是否越界  
    if (index < 0 || index >= size) {  
      throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);  
    }  
    // 如果索引小于链表长度的一半，则从头节点开始向右遍历  
    if (index < (size >> 1)) {  
      ListNode curr = dummyHead;  
      for (int i = 0; i <= index; i++) {  
        // 向右移动到下一个节点
        curr = curr.next;   
      }  
      return curr;  
    } else {  
      // 否则从尾节点开始向左遍历  
      ListNode curr = dummyTail;  
      for (int i = size - 1; i >= index; i--) {  
        // 向左移动到前一个节点
        curr = curr.prev;   
      }  
      return curr;  
    }  
  }  

  @Override  
  public String toString() {  
    StringBuilder sb = new StringBuilder("[");  
    for (ListNode curr = dummyHead.next; curr != dummyTail; curr = curr.next) {  
      sb.append(curr.val);  
      if (curr.next != dummyTail) sb.append(", ");  
    }  
    return sb.append("]").toString();  
  }  

  private class ListNode {  
    // 节点存储的值  
    private int val;  
    // 前驱指针  
    private ListNode prev;  
    // 后继指针  
    private ListNode next;  

    public ListNode() {  
    }  

    public ListNode(final int val) {  
      this.val = val;  
    }  

    public ListNode(final ListNode prev, final int val, final ListNode next) {  
      this.val = val;  
      this.prev = prev;  
      this.next = next;  
    }  

    @Override  
    public String toString() {  
      StringBuilder sb = new StringBuilder("[");  
      for (ListNode curr = this; curr != null; curr = curr.next) {  
        sb.append(curr.val);  
        if (curr.next != null) sb.append(", ");  
      }  
      return sb.append("]").toString();  
    }  
  }  
}
```

> [!example]- 双向链表（不使用虚拟头尾节点），参考自 [[LinkedList 源码剖析|JDK LinkekdList]]
>
> ```java
> class MyLinkedList {  
>   // 头节点  
>   private ListNode first;  
>   // 尾节点  
>   private ListNode last;  
>   // 链表元素个数  
>   private int size;  
> 
>   public MyLinkedList() {  
> 
>   }  
> 
>   /**  
>    * 获取链表中指定索引位置的节点值  
>    *  
>    * @param index 目标索引（0 <= index < size）  
>    * @return 如果索引合法，返回对应节点的值；否则返回 -1  
>    */  
>   public int get(int index) {  
>     // 1. 校验索引范围：若 index < 0 或 index >= size，说明越界  
>     if (index < 0 || index >= size) return -1;  
>     return node(index).val;  
>   }  
> 
>   /**  
>    * 在链表头部插入一个新节点  
>    *  
>    * @param val 新节点的值  
>    */  
>   public void addAtHead(int val) {  
>     linkFirst(val);  
>   }  
> 
>   /**  
>    * 在链表尾部插入一个新节点  
>    *  
>    * @param val 新节点的值  
>    */  
>   public void addAtTail(int val) {  
>     linkLast(val);  
>   }  
> 
>   /**  
>    * 在链表指定位置前插入一个新节点  
>    *  
>    * @param index 插入位置索引，范围 [0, size]  
>    * @param val   新节点的值  
>    * @return 无返回值  
>    *  
>    * <p>说明：  
>    * <ul>  
>    *   <li>{@code index = 0}     → 在头部插入；</li>  
>    *   <li>{@code index = size}  → 在尾部插入；</li>  
>    *   <li>{@code index < 0} 或 {@code index > size} → 操作无效，直接返回。</li>  
>    * </ul>  
>    */  
>   public void addAtIndex(int index, int val) {  
>     if (index < 0 || index > size) return;  
>     if (index == size) {  
>       // 插入到链表尾部  
>       linkLast(val);  
>     } else {  
>       // 插入到指定节点之前  
>       linkBefore(val, node(index));  
>     }  
>   }  
> 
>   /**  
>    * 删除链表中指定索引位置的节点  
>    *  
>    * @param index 要删除的节点索引，范围 [0, size - 1]  
>    * @return 无返回值  
>    *  
>    * <p>说明：  
>    * <ul>  
>    *   <li>{@code index = 0}     → 删除头节点；</li>  
>    *   <li>{@code 0 < index < size} → 删除中间节点；</li>  
>    *   <li>{@code index = size - 1} → 删除尾节点；</li>  
>    *   <li>{@code index < 0} 或 {@code index >= size} → 操作无效，直接返回。</li>  
>    * </ul>  
>    */  
>   public void deleteAtIndex(int index) {  
>     // 1. 校验索引范围：若 index 不在 [0, size-1] 之间，直接返回  
>     if (index < 0 || index >= size) return;  
>     unlink(node(index));  
>   }  
> 
>   /**  
>    * 删除指定节点  
>    *  
>    * @param x 要删除的节点  
>    */  
>   private void unlink(ListNode x) {  
>     // 记录待删除节点的前驱和后继  
>     ListNode prev = x.prev;  
>     ListNode next = x.next;  
>     /**  
>      * 处理前驱指针  
>      *  
>      * 情况1：如果 x 没有前驱（prev == null），说明 x 是头节点  
>      *       → 更新 first 指针，让头节点指向 x 的下一个节点  
>      *  
>      * 情况2：如果 x 有前驱，说明 x 在中间或尾部  
>      *       → 让前驱节点的 next 指向 x 的后继，从链表中“跳过”x  
>      *       → 同时断开 x.prev（帮助 GC 回收，避免悬挂引用）  
>      */  
>     if (prev == null) {  
>       first = next;  
>     } else {  
>       prev.next = next;  
>       x.prev = null;  
>     }  
>     /**  
>      * 处理后继指针  
>      *  
>      * 情况1：如果 x 没有后继（next == null），说明 x 是尾节点  
>      *       → 更新 last 指针，让尾节点指向 x 的前一个节点  
>      *  
>      * 情况2：如果 x 有后继，说明 x 在头部或中间  
>      *       → 让后继节点的 prev 指向 x 的前驱，从链表中“跳过”x  
>      *       → 同时断开 x.next（帮助 GC 回收，避免悬挂引用）  
>      */  
>     if (next == null) {  
>       last = prev;  
>     } else {  
>       next.prev = prev;  
>       x.next = null;  
>     }  
>     // 更新链表长度  
>     size--;  
>   }  
> 
>   /**  
>    * 在指定节点 succ 之前插入一个新节点  
>    *  
>    * @param val  新节点存储的值  
>    * @param succ 后继节点（新节点会插入在它前面）  
>    */  
>   private void linkBefore(int val, ListNode succ) {  
>     // assert succ != null  
>     // 先找到 succ 的前驱节点  
>     ListNode pred = succ.prev;  
>     // 创建新节点：前驱 = pred，值 = val，后继 = succ    
>     final ListNode newNode = new ListNode(pred, val, succ);  
>     // 让 succ 的前驱指向新节点（建立 newNode ← succ 关系）  
>     succ.prev = newNode;  
>     if (pred == null) {  
>       // 情况1：succ 没有前驱，说明 succ 原本是头节点 → 插入的新节点变成新的头节点  
>       first = newNode;  
>     } else {  
>       // 情况2：succ 有前驱→ 让前驱的 next 指向新节点（建立 pred → newNode 关系）  
>       pred.next = newNode;  
>     }  
>     // 更新链表长度  
>     size++;  
>   }  
> 
>   /**  
>    * 在链表尾部插入一个新节点  
>    *  
>    * @param val 新节点存储的值  
>    */  
>   private void linkLast(int val) {  
>     // l 指向原来的尾节点  
>     ListNode l = last;  
>     // 创建新节点：前驱 = l，值 = val，后继 = null（因为是尾节点）  
>     final ListNode newNode = new ListNode(l, val, null);  
>     // 更新 last 指针，新节点成为新的尾节点  
>     last = newNode;  
>     if (l == null) {  
>       // 情况1：原链表为空（没有尾节点）→ 新节点同时是头节点和尾节点  
>       first = newNode;  
>     } else {  
>       // 情况2：原链表非空 → 原尾节点的 next 指向新节点  
>       l.next = newNode;  
>     }  
>     // 更新链表长度  
>     size++;  
>   }  
> 
>   /**  
>    * 在链表头部插入一个新节点  
>    *  
>    * @param val 新节点存储的值  
>    */  
>   private void linkFirst(int val) {  
>     // f 指向原来的头节点  
>     ListNode f = first;  
>     // 创建新节点：前驱 = null（因为是头节点），值 = val，后继 = f   
>     final ListNode newNode = new ListNode(null, val, f);  
>     // 更新 first 指针，新节点成为新的头节点  
>     first = newNode;  
>     if (f == null) {  
>       // 情况1：原链表为空（没有头节点）→ 新节点同时是头节点和尾节点  
>       last = newNode;  
>     } else {  
>       // 情况2：原链表非空 → 原头节点的 prev 指向新节点  
>       f.prev = newNode;  
>     }  
>     // 更新链表长度  
>     size++;  
>   }  
> 
>   /**  
>    * 根据索引定位节点  
>    *  
>    * <p> 若 index < size / 2，则从头节点 dummyHead 开始向右遍历，否则从尾节点 dummyTail 开始向左遍历。</p>  
>    *  
>    * @param index 节点索引（0 <= index < size）  
>    * @return 对应位置的节点  
>    * @throws IndexOutOfBoundsException 如果 index 越界  
>    */  
>   private ListNode node(int index) {  
>     // 检查索引是否越界  
>     if (index < 0 || index >= size) {  
>       throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);  
>     }  
>     // 如果索引小于链表长度的一半，则从头节点开始向右遍历  
>     if (index < (size >> 1)) {  
>       ListNode curr = first;  
>       for (int i = 0; i < index; i++) {  
>         // 向右移动到下一个节点  
>         curr = curr.next;  
>       }  
>       return curr;  
>     } else {  
>       // 否则从尾节点开始向左遍历  
>       ListNode curr = last;  
>       for (int i = size - 1; i > index; i--) {  
>         // 向左移动到前一个节点  
>         curr = curr.prev;  
>       }  
>       return curr;  
>     }  
>   }  
> 
>   @Override  
>   public String toString() {  
>     StringBuilder sb = new StringBuilder("[");  
>     for (ListNode curr = first; curr != null; curr = curr.next) {  
>       sb.append(curr.val);  
>       if (curr.next != null) sb.append(", ");  
>     }  
>     return sb.append("]").toString();  
>   }  
> 
>   private class ListNode {  
>     // 节点存储的值  
>     private int val;  
>     // 前驱指针  
>     private ListNode prev;  
>     // 后继指针  
>     private ListNode next;  
> 
>     public ListNode() {  
>     }  
> 
>     public ListNode(final int val) {  
>       this.val = val;  
>     }  
> 
>     public ListNode(final ListNode prev, final int val, final ListNode next) {  
>       this.val = val;  
>       this.prev = prev;  
>       this.next = next;  
>     }  
> 
>     @Override  
>     public String toString() {  
>       StringBuilder sb = new StringBuilder("[");  
>       for (ListNode curr = this; curr != null; curr = curr.next) {  
>         sb.append(curr.val);  
>         if (curr.next != null) sb.append(", ");  
>       }  
>       return sb.append("]").toString();  
>     }  
>   }  
> }
> ```
