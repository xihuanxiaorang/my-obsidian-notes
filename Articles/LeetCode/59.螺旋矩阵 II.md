---
tags:
  - LeetCode
  - Algorithm
level: MEDIUM
categories:
  - 数组
  - 模拟
create_time: 2025/08/18 18:08
update_time: 2025/08/19 21:52
---

## 题目描述

给你一个正整数 $n$，生成一个包含 $1$ 到 $n^2$ 所有元素，且元素按 **顺时针顺序螺旋排列** 的 $n \times n$ 正方形矩阵 `matrix`。

**示例 1：**

![](https://img.xiaorang.fun/202508191652879.png)

```text
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

**示例 2：**

```text
输入：n = 1
输出：[[1]]
```

**提示：**

- `1 <= n <= 20`

## 解法

### 方法一：模拟

#### 解题思路

![](https://img.xiaorang.fun/202508191652879.png)

根据题意，我们从左上角 $(0,0)$ 出发，按照顺时针方向（右→下→左→上）前进：
- 首先向右走，如果到达矩阵边界或遇到已填入数字的位置，则顺时针旋转 $90^\circ$，前进方向变为向下。
- 然后向下走，同样在到达边界或遇到已填数字时顺时针旋转 $90^\circ$，前进方向变为向左。
- 然后向左走，到达边界或遇到已填数字时顺时针旋转 $90^\circ$，前进方向变为向上。
- 然后向上走，到达边界或遇到已填数字时顺时针旋转 $90^\circ$，前进方向变为向右。
- 重复上述过程，直至填入数字 $1 \sim n^2$。

> [!info] 顺时针旋转 $90^\circ$  公式
> $(dx,dy)\gets(dy,-dx)$

实现细节：
1. 初始化一个 $n \times n$ 的矩阵 $ans$，所有元素初始为 $0$。
2. 定义方向数组 `dirs=[(0,1),(1,0),(0,−1),(−1,0)]` 分别表示右→下→左→上。用下标 `di` 表示当前方向，初始值为 $0$，表示一开始向右。
3. 每次移动，将当前行号和列号分别增加 `dirs[di][0]` 和 `dirs[di][1]`。
4. 每次需要转向时，更新方向下标为：$dir \gets (dir + 1) \bmod 4$，这样即可实现顺时针循环。

#### 代码实现

```java
class Solution {
  public int[][] generateMatrix(int n) {
    // 初始化 n x n 的矩阵，所有元素为 0
    int[][] ans = new int[n][n];
    // 定义方向数组 dirs，顺序为右→下→左→上,每个方向用 (行增量, 列增量) 表示
    int[][] dirs = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    // 初始化当前位置 (i,j) 为矩阵左上角
    int i = 0, j = 0;
    // 当前方向下标 di，初始为 0，表示向右
    int di = 0;
    // 5. 循环填充数字 1~n^2
    for (int num = 1; num <= n * n; num++) {
      // 将当前数字填入矩阵
      ans[i][j] = num;
      // 计算下一步位置
      int x = i + dirs[di][0];
      int y = j + dirs[di][1];
      // 判断下一步是否需要顺时针旋转 90°，条件：越界或该位置已经填过数字
      if (x < 0 || x >= n || y < 0 || y >= n || ans[x][y] != 0) {
        // 顺时针旋转方向
        di = (di + 1) % 4; 
      }
      // 更新下一步位置为旋转后的方向
      i = i + dirs[di][0];
      j = j + dirs[di][1];
    }
    // 返回填好的螺旋矩阵
    return ans;
  }
}
```

时间复杂度 $O(n^2)$，其中 $n$ 是给定的正整数。

空间复杂度 $O(1)$，忽略答案数组的空间消耗，只需要维护常量空间。

### 方法二：按层模拟

#### 解题思路

初始化一个 $n \times n$ 的矩阵 $ans$，然后模拟顺时针螺旋填数的过程：

1. 初始化：
   - 上边界：$t=0$
   - 下边界：$b=n - 1$
   - 左边界：$l=0$
   - 右边界：$r=n - 1$
   - 当前填入数字：$num=1$ ​
2. 无限循环 `while (true)`，每一轮循环按照顺时针方向依次填数：
   1. 从左到右：在区间 $[l, r]$ 内填充 $ans[t][j]$，然后更新 $t \gets t + 1$（上边界向内缩 $1$）。若 $t > b$，则退出循环。
   2. 从上到下：在区间 $[t, b]$ 内填充 $ans[i][r]$，然后更新 $r \gets r - 1$（右边界向内缩 $1$）。若 $l > r$，则退出循环。
   3. 从右到左：在区间 $[r, l]$ 内填充 $ans[b][j]$，然后更新 $b \gets b - 1$（下边界向内缩 $1$）。若 $t > b$，则退出循环。
   4. 从下到上：在区间 $[b, t]$ 内填充 $ans[i][l]$，然后更新 $l \gets l + 1$（左边界向内缩 $1$）。若 $l > r$，则退出循环。
   5. 每填入一个元素，都执行 $num \gets num + 1$。
3. 当循环结束时，整个矩阵已全部填满，返回 $ans$ 即可。

![](https://img.xiaorang.fun/202508191754499.png)

#### 代码实现

```java
class Solution {
  public int[][] generateMatrix(int n) {
    // 初始化结果矩阵
    int[][] ans = new int[n][n];
    // 定义边界：t=上边界，b=下边界，l=左边界，r=右边界
    int t = 0, b = n - 1, l = 0, r = n - 1;
    // 当前要填入的数字
    int num = 1;
    // 按照顺时针方向不断填数，直到矩阵填满
    while (true) {
      // 1. 从左到右填充上边界
      for (int j = l; j <= r; j++) ans[t][j] = num++;
      // 上边界向内缩 1，若越界则结束循环
      if (++t > b) break;
      // 2. 从上到下填充右边界
      for (int i = t; i <= b; i++) ans[i][r] = num++;
      // 右边界向内缩 1，若越界则结束循环
      if (--r < l) break;
      // 3. 从右到左填充下边界
      for (int j = r; j >= l; j--) ans[b][j] = num++;
      // 下边界向内缩 1，若越界则结束循环
      if (--b < t) break;
      // 4. 从下到上填充左边界
      for (int i = b; i >= t; i--) ans[i][l] = num++;
      // 左边界向内缩 1，若越界则结束循环
      if (++l > r) break;
    }
    // 返回结果矩阵
    return ans;
  }
}
```

时间复杂度 $O(n^2)$，其中 $n$ 是给定的正整数。

空间复杂度 $O(1)$，忽略答案数组的空间消耗，只需要维护常量空间。
