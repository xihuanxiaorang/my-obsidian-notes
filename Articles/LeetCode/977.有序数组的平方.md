---
tags:
  - LeetCode
level: EASY
categories:
  - 数组
  - 双指针
create_time: 2025/08/16 10:40
update_time: 2025/08/19 21:50
---

## 题目描述

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

**示例 1：**

```text
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
```

**示例 2：**

```text
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
```

**提示：**

- `1 <= nums.length <= 10^4`
- `-10^4 <= nums[i] <= 10^4`
- `nums` 已按 **非递减顺序** 排序

**进阶：**

- 请你设计时间复杂度为 `O(n)` 的算法解决本问题

## 解法

### 方法一

#### 解题思路

由于数组 $nums$ ​ 已经按照非递减顺序排好序，因此：
- 数组负数部分的绝对值从左到右逐渐减小，因此其平方值从左到右是递减的；
- 数组正数部分本身从左到右逐渐增大，因此其平方值从左到右是递增的；
- 整体呈现，**数组两端元素平方值较大，中间元素平方值较小**。

因此可以使用**双指针**法：分别从数组两端向中间遍历，每次比较两端元素的平方值，将较大的那个放入结果数组的末尾，然后移动对应的指针。

算法步骤如下：
1. 初始化结果数组 ${ans}$，长度为 $n$。
2. 初始化左指针 $i = 0$，右指针 $j = n - 1$，以及结果数组下标 $p = n - 1$，表示要往 ${ans}[p]$ 填入数据。
3. 设：$x = \text{nums}[i]$，$y = \text{nums}[j]$
4. 若 $x > y$，则将 $x$ 填入 ${ans}[p]$，然后 $i$ 加一，$p$ 减一。
5. 若 $x < y$，则将 $y$ 填入 ${ans}[p]$，然后 $j$ 减一，$p$ 减一。
6. 重复步骤 3–5，直至 $p = -1$，即所有数据都填入 ${ans}$。
7. 返回 ${ans}$。

#### 代码实现

```java
class Solution {
  public int[] sortedSquares(int[] nums) {
    int n = nums.length;
    // 结果数组，存放平方后的递增序列
    int[] ans = new int[n];
    // 双指针：i 指向最左端，j 指向最右端
    // p 表示当前要填入结果数组的位置（从后往前）
    for (int i = 0, j = n- 1, p = n - 1; p >= 0; p--) {
      // 分别计算两端元素的平方值
      int x = nums[i] * nums[i];
      int y = nums[j] * nums[j];
      // 比较两端平方值，较大的放入结果数组的末尾
      if (x > y) {
        ans[p] = x;
        // 左指针右移
        i++;
      } else {
        ans[p] = y;
        // 右指针左移
        j--;
      }
    }
    // 返回结果数组
    return ans;
  }
}
```

时间复杂度 $O(n)$，其中 $n$ 是数组 $nums$ 的长度。

空间复杂度 $O(1)$，忽略答案数组的空间消耗，只需要维护常量空间。
