---
tags:
  - LeetCode
  - Algorithm
level: EASY
categories:
  - 链表
  - 双指针
  - 递归
create_time: 2025/08/16 22:18
update_time: 2025/08/26 18:09
---

## 题目描述

给你单链表的头节点 `head`，请你反转链表，并返回反转后的链表。

**示例 1：**

![](https://img.xiaorang.fun/202508242259661.png)

```text
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**示例 2：**

![](https://img.xiaorang.fun/202508242259663.png)

```text
输入：head = [1,2]
输出：[2,1]
```

**示例 3：**

```text
输入：head = []
输出：[]
```

**提示：**

- 链表中节点的数目范围是 `[0, 5000]`
- `-5000 <= Node.val <= 5000`

**进阶：**
链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

## 解法

### 方法一：双指针（头插法）

#### 解题思路

![[LeetCode 206.反转链表（双指针、头插法）|800]]

1. 定义两个指针：`pre` 指向已反转部分的头，`curr` 指向当前待处理节点，初始时 `pre = null`，`curr = head`。
2. 遍历链表时，先用 `next` 暂存 `curr.next`，避免链表断开；再将 `curr.next` 指向 `pre`，完成当前节点的反转；最后整体向前推进：`pre` 移到 `curr`，`curr` 移到 `next`。
3. 当 `curr` 遍历到空时，说明链表已全部反转，返回 `pre` 作为新的头节点。

#### 代码实现

```java
/**  
 * 反转链表  
 *  
 * @param head 链表头节点  
 * @return 反转后的链表头节点  
 */  
public ListNode reverseList(ListNode head) {  
  // 初始化前一个节点为 null，当前节点为头节点  
  ListNode pre = null, curr = head;  
  // 当当前节点不为空时循环  
  while (curr != null) {  
    // 暂存当前节点的下一个节点  
    ListNode next = curr.next;  
    // 将当前节点指向前一个节点，实现反转  
    curr.next = pre;  
    // 移动 pre 和 curr 指针，pre 向前移动到 curr，curr 向前移动到 next    
    pre = curr;  
    curr = next;  
  }  
  // 返回新的头节点，即原来的尾节点  
  return pre;  
}
```

时间复杂度：$O(n)$，其中 $n$ 是链表的长度。

空间复杂度：$O(1)$。

> [!example]- 根据双指针推导出的递归写法
>
> ```java
> class Solution {  
>   public ListNode reverseList(ListNode head) {  
>     // 调用递归辅助函数，初始时 pre = null，curr = head  
>     return reverse(null, head);  
>   }  
> 
>   /**
>    * 递归反转链表
>    * @param pre  已反转部分的头节点
>    * @param curr 当前待处理节点
>    * @return     反转后的新头节点
>    */
>   private ListNode reverse(ListNode pre, ListNode curr) {  
>     // 递归终止条件：当 curr 遍历到 null，说明链表已全部反转，返回 pre 作为新的头节点  
>     if (curr == null) return pre;  
>     // 暂存当前节点的下一个节点，防止链表断开  
>     ListNode next = curr.next;  
>     // 将当前节点指向前一个节点，实现反转  
>     curr.next = pre;  
>     // 递归处理下一个节点：pre 前移到 curr，curr 前移到 next  
>     return reverse(curr, next);  
>   }  
> }
> ```

### 方法二：递归

> [!important] #Algorithm/递归
> 1. 大问题拆分成相同形式的子问题
> 2. 子问题的求解方式和大问题一致
> 3. 存在可直接求解的最小子问题（递归终止条件）

#### 解题思路

![[LeetCode 206.反转链表（递归整体示意图）|800]]

![[LeetCode 206.反转链表（回溯细节示意图）|800]]

递归的核心思想是：先递归到链表尾部，再在回溯过程中逐步反转指针。
1. 递归终止条件：当 `head` 为空或 `head.next` 为空时，说明链表为空或只有一个节点，此时直接返回 `head`，作为反转后链表的新头节点。
2. 递归假设：调用 `reverseList(head.next)`，假设以 `head.next` 为起点的子链表已经完成反转，并返回新的头节点 `newHead`。
3. 回溯过程：
	1. 反转指针：让 `head.next.next = head`，即子节点指向当前节点，实现链表反转。
	2. 断开连接：将 `head.next = null`，避免链表形成环。

#### 代码实现

```java
class Solution {  
  /**  
   * 反转链表  
   *  
   * @param head 链表头节点  
   * @return 反转后的链表头节点  
   */  
  public ListNode reverseList(ListNode head) {  
    // 如果当前节点为空，或者当前节点没有下一个节点，则直接返回当前节点。  
    // 这种情况发生在链表为空或遍历到原链表的最后一个节点时。  
    if (head == null || head.next == null) return head;  
    // 递归调用reverseList方法，传入当前节点的下一个节点作为参数。  
    // 这个递归调用会一直进行下去，直到遇到链表的最后一个节点。  
    final ListNode newHead = reverseList(head.next);  
    // 当递归开始回溯时，将当前节点的下一个节点的next指针指向当前节点。  
    // 这一步实现了链表反转的关键操作，即改变节点之间的链接方向。  
    head.next.next = head;  
    // 将当前节点的next指针设置为null。这一步对于防止形成循环链表非常重要。  
    // 在完成链表反转后，原来的链表头节点将成为新的链表尾节点，其next指针应该指向null。  
    head.next = null;  
    // 返回新的链表头节点。随着递归的回溯，newHead始终指向反转后链表的第一个节点。  
    return newHead;  
  }  
}
```

时间复杂度：$O(n)$，其中 $n$ 是链表的长度。需要对链表的每个节点进行反转操作。

空间复杂度：$O(n)$，其中 $n$ 是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 $n$ 层。
