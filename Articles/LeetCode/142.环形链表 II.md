---
tags:
  - LeetCode
  - Algorithm
level: MEDIUM
categories:
  - 链表
  - 快慢指针
  - 哈希表
create_time: 2025/08/16 22:18
update_time: 2025/08/28 18:55
---

## 题目描述

给定一个链表的头节点 `head`，返回链表开始入环的第一个节点。*如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改**链表。

**示例 1：**

![](https://img.xiaorang.fun/202508281855145.png)

```text
输入：head = [3,2,0,-4], pos = 1  
输出：返回索引为 1 的链表节点  
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![](https://img.xiaorang.fun/202508281855146.png)

```text
输入：head = [1,2], pos = 0  
输出：返回索引为 0 的链表节点  
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![](https://img.xiaorang.fun/202508281855147.png)

```text
输入：head = [1], pos = -1  
输出：返回 null  
解释：链表中没有环。
```

**提示：**

- 链表中节点的数目范围在 `[0, 10^4]` 内
- `-10^5 <= Node.val <= 10^5`
- `pos` 的值为 `-1` 或者链表中的一个有效索引

**进阶：**
你是否可以使用 `O(1)` 空间解决此题？

## 解法

### 方法一：哈希表

#### 解题思路

思路非常直观：
1. 从头节点开始遍历链表，并用一个哈希表（或集合）来存储已经访问过的节点。
2. 遍历过程中，每到一个新节点，就检查它是否已经在哈希表中出现过。
	- 如果已经出现过，说明链表中存在环，并且第一次重复出现的节点就是环的入口。
	- 如果没有出现过，就将该节点加入哈希表，然后继续向后遍历。
3. 如果遍历到链表末尾（即遇到 `null`），说明链表中没有环，直接返回 `null`。

这种方法的关键点在于，利用哈希表的快速查找能力，可以在第一次遇到环入口时立刻返回结果，而不必继续遍历。

#### 代码实现

```java
public class Solution {  
  /**  
   * 检测链表中是否存在环，并返回环的起始节点。  
   *  
   * @param head 链表头节点  
   * @return 环的起始节点，如果不存在环则返回 null  
   */  
  public ListNode detectCycle(ListNode head) {  
    // 创建一个集合来存储已经访问过的节点  
    Set<ListNode> visited = new HashSet<>();  
    // 初始化当前节点为链表头节点  
    ListNode curr = head;  
    // 当前节点不为空时循环  
    while (curr != null) {  
      // 如果当前节点已经在访问过的集合中，说明找到了环的入口  
      if (visited.contains(curr)) {  
        return curr;  // 返回环的起始节点  
      } else {  
        // 否则，将当前节点添加到已访问的集合中  
        visited.add(curr);  
      }  
      // 移动当前节点到下一个节点  
      curr = curr.next;  
    }  
    // 如果遍历完整个链表都没有发现环，则返回 null    
    return null;  
  }  
}
```

时间复杂度：$O(N)$，其中 $N$ 为链表中节点的数目。需要访问链表中的每一个节点。

空间复杂度：$O(N)$，其中 $N$ 为链表中节点的数目。需要将链表中的每个节点都保存在哈希表当中。

### 方法二：快慢指针

#### 解题思路

定义两个指针 `slow` 和 `fast`，初始都指向链表头节点。遍历过程中，`slow` 每次前进 $1$ 步，`fast` 每次前进 $2$ 步。若链表存在环，则二者必定会在环内某一点相遇；若 `fast` 或其下一个节点为空，则说明链表无环。

如下图所示，设链表环外部分长度为 $a$，环的长度为 $b+c$。当 `slow` 进入环后走了 $b$ 的距离与 `fast` 相遇，此时：
- `slow` 的路程：$a+b$
- `fast` 的路程：$a+n(b+c)+b$

![](https://img.xiaorang.fun/202508281854801.png)

由于 `fast` 的速度始终是 `slow` 的 2 倍，满足：

$$
a+n(b+c)+b=2(a+b)⟹a=c+(n−1)(b+c)
$$

这说明：从链表头到环入口的距离 $a$，等于从相遇点继续走到环入口的距离 $c$，再加上若干圈环长。

因此，在 `slow` 与 `fast` 两指针相遇后，再引入一个新指针 `p` 从头节点出发，与 `slow` 同步前进（每次一步），两者最终会在环的入口相遇，该节点即为答案。

#### 代码实现

```java
public class Solution {  
  /**  
   * 检测链表中是否存在环，并返回环的起始节点。  
   *  
   * @param head 链表头节点  
   * @return 环的起始节点，如果不存在环则返回 null  
   */  
  public ListNode detectCycle(ListNode head) {  
    // 初始化两个指针：慢指针 slow 和快指针 fast，都指向链表头节点  
    ListNode slow = head, fast = head;  
    // 当快指针 fast 及其下一个节点不为空时循环  
    while (fast != null && fast.next != null) {  
      // 快指针每次移动两步  
      fast = fast.next.next;  
      // 慢指针每次移动一步  
      slow = slow.next;  
      // 如果快指针和慢指针相遇，说明链表中存在环  
      if (fast == slow) {  
        // 初始化一个新的指针 p，从链表头节点开始  
        ListNode p = head;  
        // 移动 p 和 slow 直到它们相遇，相遇点即为环的起始节点  
        while (p != slow) {  
          p = p.next;  // 移动 p 指针  
          slow = slow.next;  // 移动 slow 指针  
        }  
        // 返回环的起始节点  
        return p;  
      }  
    }  
    // 如果遍历完整个链表都没有发现环，则返回 null    
    return null;  
  }  
}
```
