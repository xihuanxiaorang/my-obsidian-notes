---
tags:
  - LeetCode
  - Algorithm
level: EASY
categories:
  - 链表
create_time: 2025/08/16 22:18
update_time: 2025/08/21 18:12
---

## 题目描述

给你一个链表的头节点 `head` 和一个整数 `val`，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点**。

**示例 1：**

![](https://img.xiaorang.fun/202508192306142.png)

```text
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```

**示例 2：**

```text
输入：head = [], val = 1
输出：[]
```

**示例 3：**

```text
输入：head = [7,7,7,7], val = 7
输出：[]
```

**提示：**

- 链表中的节点数目在范围 <code>[0, 10<sup>4</sup>]</code> 内
- `1 <= Node.val <= 50`
- `0 <= val <= 50`

## 解法

> [!tip]
> 删除节点时，先找到其前驱节点 `prev`，然后将前驱节点的 `next` 指向该节点的后继节点，从而跳过该节点，实现删除。
> $$
> prev.next = prev.next.next
> $$
> ![[单向链表-删除节点|800]]

### 方法一

#### 解题思路

1. 处理头节点：由于头节点没有前驱节点，需单独判断。若头节点的值等于 `val`，则将 `head` 指向下一个节点（即新的头节点），并持续检查新的头节点是否仍需删除。
2. 遍历链表并删除目标节点：
	1. 定义指针 `curr` 指向头节点，用于遍历链表。
	2. 使用 `while` 循环遍历，直至 `curr` 或 `curr.next` 为空。
	3. 在循环中：
		- 若 `curr.next` 节点的值等于 `val`，则删除该节点（即 `curr.next = curr.next.next`）。
		- 否则，将 `curr` 向后移动（即  `curr = curr.next`），继续遍历。
3. 返回处理后的链表头节点 `head`。

#### 代码实现

```java
class Solution {
  public ListNode removeElements(ListNode head, int val) {
    // 1. 处理头节点：若头节点的值等于 val，则不断向后移动 head，直至头节点为 null 或者头节点的值不等于 val 为止
    while (head != null && head.val == val) {
      head = head.next;
    }
    // 2. 定义指针 curr 指向头节点 head，从头节点开始遍历链表
    ListNode curr = head;
    // 3. 遍历链表并删除目标节点，直至 curr 或 curr.next 为 null
    while (curr != null && curr.next != null) {
      if (curr.next.val == val) {
        // 3.1 如果下一个节点的值等于 val，则删除该节点，即让 curr.next 指向 curr.next.next
        curr.next = curr.next.next;
      } else {
        // 3.2 否则，将 curr 向后移动，继续遍历
        curr = curr.next;
      }
    }
    // 返回处理后的链表头节点
    return head;
  }
}
```

时间复杂度：$O(n)$，其中 $n$ 是链表的长度。

空间复杂度：$O(1)$。

### 方法二：虚拟头节点

#### 解题思路

在头节点前添加一个虚拟头节点 `dummy`，其 `next` 指向头节点 `head`，用于处理头节点本身就是要删除节点时的边界情况，统一操作逻辑。

1. 初始化虚拟头节点 `dummy`，其 `next` 指向 `head`。
2. 遍历链表并删除目标节点：
	1. 定义指针 `curr` 指向虚拟头节点 `dummy`。
	2. 使用 `while` 循环遍历，直至 `curr.next` 为空。
	3. 在循环中：
		- 若 `curr.next` 节点的值等于 `val`，则删除该节点（`curr.next = curr.next.next`）。
		- 否则，将 `curr` 向后移动（即  `curr = curr.next`），继续遍历。
3. 返回处理后的链表头节点 `dummy.next`。

#### 代码实现

```java
class Solution {  
  public ListNode removeElements(ListNode head, int val) {  
    // 1. 初始化虚拟头节点 dummy，其 next 指向头节点 head
    final ListNode dummy = new ListNode(-1, head); 
    // 2. 定义指针 curr 指向虚拟头节点 dummy，从虚拟头节点开始遍历链表
    ListNode curr = dummy;  
    // 3. 遍历链表并删除目标节点，直至 curr.next 为 null
    while (curr.next != null) {  
      if (curr.next.val == val) {  
        // 3.1 如果下一个节点的值等于 val，则删除该节点，即让 curr.next 指向 curr.next.next
        curr.next = curr.next.next;  
      } else {  
        // 3.2 否则，将 curr 向后移动，继续遍历
        curr = curr.next;  
      }  
    } 
    // 返回处理后的链表头节点
    return dummy.next;  
  }  
}
```

时间复杂度：$O(n)$，其中 $n$ 是链表的长度。

空间复杂度：$O(1)$。
