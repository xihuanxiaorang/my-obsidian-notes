---
tags:
  - LeetCode
  - Algorithm
level: MEDIUM
categories:
  - 数组
  - 双指针
  - 滑动窗口
create_time: 2025/08/16 22:17
update_time: 2025/08/31 17:15
---

## 题目描述

给定一个含有 `n` 个正整数的数组和一个正整数 `target`。

找出该数组中满足其总和 **大于等于 `target`** 的长度最小的 **子数组** <code>[nums<sub>l</sub>, nums<sub>l+1</sub>, …, nums<sub>r-1</sub>, nums<sub>r</sub>]</code>，并返回其长度。如果不存在符合条件的子数组，返回 `0`。

**示例 1：**

```text
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```text
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例 3：**

```text
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

**提示：**

- <code>1 &lt;= target &lt;= 10<sup>9</sup></code>
- <code>1 &lt;= nums. length &lt;= 10<sup>5</sup></code>
- <code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code>

**进阶：**

- 如果你已经实现 $O(n)$ 时间复杂度的解法，请尝试设计一个 $O(nlogn)$ 时间复杂度的解法。

## 解法

### 方法一：暴力法

#### 解题思路

最直观的做法是枚举所有可能的子数组：

1. 初始化最小子数组长度为一个极大值；
2. 外层循环：枚举子数组的起点下标 $i$；
3. 内层循环：从起点下标 $i$ 开始，枚举子数组的终点下标 $j$，并累加区间和。
	- 当区间和大于等于 $target$ 时，立即终止内层循环；
	- 记录子数组长度为 $j-i+1$，并与当前最小子数组长度比较，取较小值作为新的最小子数组长度。

#### 代码实现

```java
class Solution {
  public int minSubArrayLen(int target, int[] nums) {
    int n = nums.length;
    // 如果数组为空，直接返回 0
    if (n == 0) {
      return 0;
    }
    // 初始化最小子数组长度为一个极大值
    int ans = Integer.MAX_VALUE;
    // 外层循环：枚举子数组的起点下标 i
    for (int i = 0; i < nums.length; i++) {
      // 记录从 i 开始累加的区间和
      int sum = 0; 
      // 内层循环：枚举子数组的终点下标 j
      for (int j = i; j < nums.length; j++) {
        // 累加区间和
        sum += nums[j]; 
        // 一旦区间和大于等于 target
        if (sum >= target) {
          // 更新最小子数组长度
          ans = Math.min(ans, j - i + 1);
          // 由于继续增加 j 只会让子数组更长，不可能更优，所以直接终止内层循环
          break;
        }
      }
    }
    // 如果 ans 没有被更新过，说明不存在符合条件的子数组，返回 0；否则返回最小长度
    return ans == Integer.MAX_VALUE ? 0 : ans;
  }
}
```

时间复杂度: $O(n^2)$，其中 $n$ 是数组的长度。

空间复杂度: $O(1)$。

### 方法二：滑动窗口

#### 解题思路

由于数组 $nums$ 中的元素均为正整数，因此可以考虑使用双指针来维护一个滑动窗口。

1. 定义两个指针 $i$ 和 $j$ 分别表示滑动窗口的左边界和右边界，用一个变量 $\text{sum} = \sum_{k=i}^{j} \text{nums}[k]$ 表示当前窗口的元素和，初始化子数组的最小长度 $\text{ans} = \texttt{Integer.MAX\_VALUE}$。
2. 在每一轮迭代中，移动右指针 $\textit{j}$，将 $nums[j]$ 加入窗口，即 $sum \leftarrow sum + nums[j]$。若此时满足 $sum \geq target$，则说明窗口 $[i, j]$ 是一个可行解，更新子数组的最小长度 $ans = \min(ans, j - i + 1)$。随后收缩左边界：循环执行 $sum \leftarrow sum - nums[i]$，$i \leftarrow i + 1$，并在收缩过程中持续更新子数组的最小长度 $ans = \min(ans, j - i + 1)$，直至 $sum < target$ 为止。

最后，如果子数组的最小长度 $ans$ 仍为初始值 $\texttt{Integer.MAX\_VALUE}$，则说明不存在满足条件的子数组，返回 $0$；否则返回 $ans$。

#### 代码实现

```java
class Solution {
  public int minSubArrayLen(int target, int[] nums) {
    int n = nums.length;
    // 如果数组为空，直接返回 0
    if (n == 0) {
      return 0;
    }
    // i: 左指针，sum: 当前滑动窗口元素和，ans: 最小子数组长度（初始化为极大值）
    int i = 0;
    int sum = 0;
    int ans = Integer.MAX_VALUE;
    // 外层循环：枚举右指针 j，逐步扩展滑动窗口
    for (int j = 0; j < nums.length; j++) {
      // 将 nums[j] 加入窗口，更新元素和
      sum += nums[j];
      // 内层循环：当窗口内元素和满足条件时，尝试收缩左边界
      while (sum >= target) {
        // 窗口 [i, j] 已经是一个可行解，更新最小子数组长度
        ans = Math.min(ans, j - i + 1);
        // 收缩左边界：移除 nums[i]，并右移左指针
        sum -= nums[i];
        i++;
      }
    }
    // 如果 ans 仍为初始值，则说明不存在满足条件的子数组，返回 0，否则返回 ans
    return ans == Integer.MAX_VALUE ? 0 : ans;
  }
}
```

时间复杂度: $O(n)$，其中 $n$ 为数组 $nums$ 的长度。

空间复杂度: $O(1)$。
