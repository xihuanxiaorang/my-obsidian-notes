---
tags:
  - LeetCode
  - Algorithm
level: Easy
categories:
  - 数组
  - 二分查找
create_time: 2025/08/14 19:06
update_time: 2025/08/16 10:36
---

## 题目描述

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target`，写一个函数搜索 `nums` 中的 `target`，如果 `target` 存在返回下标，否则返回 `-1`。

你必须编写一个具有 `O(log n)` 时间复杂度的算法。

**示例 1:**

```text
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例 2:**

```text
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

**提示：**

1. 你可以假设 `nums` 中的所有元素是不重复的。
2. `n` 将在 `[1, 10000]` 之间。
3. `nums` 的每个元素都将在 `[-9999, 9999]` 之间。

## 解法

两种区间定义：

![](https://img.xiaorang.fun/202508151303038.png)

如上图所示，在两种区间表示下，二分查找算法的初始化、循环条件和缩小区间操作皆有所不同。

由于"双闭区间"表示中的左右边界都被定义为闭区间，因此通过指针 $i$ 和指针 $j$ 缩小区间的操作也是对称的。这样更不容易出错，**因此一般建议采用"双闭区间"的写法**。

### 方法一：左闭右闭区间

#### 解题思路

![](https://img.xiaorang.fun/202508142341133.gif)

如上图所示，先初始化指针 $i = 0$ 和 $j = n - 1$，分别指向数组首元素和尾元素，代表搜索区间 `[0, n - 1]`。请注意，中括号表示闭区间，其包含边界值本身。

接下来，循环执行以下两步。

1. 计算中点索引 $m = \lfloor {(i + j) / 2} \rfloor$，其中 $\lfloor \: \rfloor$ 表示向下取整操作。
2. 判断 `nums[m]` 和 `target` 的大小关系，分为以下三种情况。
   1. 当 `nums[m] < target` 时，说明 `target` 在区间 $[m + 1, j]$ 中，因此执行 $i = m + 1$。
   2. 当 `nums[m] > target` 时，说明 `target` 在区间 $[i, m - 1]$ 中，因此执行 $j = m - 1$。
   3. 当 `nums[m] = target` 时，说明找到 `target`，因此返回索引 $m$ ​。

若数组不包含目标元素，搜索区间最终会缩小为空。此时返回 $-1$。

> [!caution]
>
> 由于 $i$ 和 $j$ 都是 `int` 类型，**因此 $i + j$ 可能会超出 `int` 类型的取值范围**。为了避免大数越界，我们通常采用公式 $m = \lfloor {i + (j - i) / 2} \rfloor$ 来计算中点。

#### 完整答案

```java
class Solution {
  /* 二分查找（双闭区间） */
  public int search(int[] nums, int target) {
    // 初始化双闭区间 [0, n-1] ，即 i, j 分别指向数组首元素、尾元素
    int i = 0, j = nums.length - 1;
    // 循环，当搜索区间为空时跳出（当 i > j 时为空）
    while(i <= j) {
      // 计算中点索引 m
      int m = i + (j - i) / 2;
      if(nums[m] < target) { // 此情况说明 target 在区间 [m+1, j] 中
        i = m + 1;
      } else if(nums[m] > target) { // 此情况说明 target 在区间 [i, m-1] 中
        j = m - 1;
      } else { // 找到目标元素，返回其索引
        return m;
      }
    }
    // 未找到目标元素，返回 -1
    return -1;
  }
}
```

时间复杂度为 $O(\log n)$：在二分循环中，区间每轮缩小一半，因此循环次数为 $\log_2 n$ ​。

空间复杂度为 $O(1)$：指针 $i$ 和 $j$ 使用常数大小空间。

### 方法二：左闭右开区间

#### 解题思路

除了上述双闭区间外，常见的区间表示还有"左闭右开"区间，定义为 $[0, n)$，即左边界包含自身，右边界不包含自身。在该表示下，区间 $[i, j)$ 在 $i = j$ 时为空。

可以基于该表示实现具有相同功能的二分查找算法。

#### 完整答案

```java
class Solution {
  /* 二分查找（左闭右开区间） */
  public int search(int[] nums, int target) {
    // 初始化左闭右开区间 [0, n) ，即 i, j 分别指向数组首元素、尾元素+1
    int i = 0, j = nums.length;
     // 循环，当搜索区间为空时跳出（当 i = j 时为空）
    while(i < j) {
      // 计算中点索引 m
      int m = i + (j - i) / 2;
      if(nums[m] < target) {  // 此情况说明 target 在区间 [m+1, j) 中
        i = m + 1;
      } else if(nums[m] > target) {  // 此情况说明 target 在区间 [i, m) 中
        j = m;
      } else { // 找到目标元素，返回其索引
        return m;
      }
    }
    // 未找到目标元素，返回 -1
    return -1;
  }
}
```
