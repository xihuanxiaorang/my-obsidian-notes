---
tags:
  - LeetCode
  - Algorithm
level: EASY
categories:
  - 数组
  - 哈希表
create_time: 2025/08/16 22:18
update_time: 2025/08/30 11:06
---

## 题目描述

给定两个数组 `nums1` 和 `nums2`，返回它们的 **交集**。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序**。

**示例 1：**

```text
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
```

**示例 2：**

```text
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的
```

**提示：**

- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 1000`

## 解法

### 方法一：哈希表

#### 解题思路

题目要求返回两个数组的交集，且每个元素在结果中只出现一次。为了高效判断一个元素是否在另一个数组中，使用哈希表（HashSet）存储元素。
1. 长度优化：为了减少空间开销，始终用较短的数组来构建哈希表。如果 `nums1` 比 `nums2` 长，则交换两者。
2. 存储元素：将较短数组的所有元素存入哈希表 `table`，这样可以在 $O(1)$ 平均时间复杂度下判断某个数是否存在。
3. 查找交集：遍历另一个数组 `nums2`，如果某个元素在 `table` 中存在，就将其加入结果 `Set` 集合 `ans`。使用集合的好处是自动去重，避免重复添加相同元素。
4. 结果返回：最后将结果集合 `ans` 转换为数组并返回。

该方法利用了哈希表高效查找的特点，将时间复杂度降低到 $O(m+n)$，同时保证了结果的唯一性。

#### 代码实现

```java
class Solution {  
  /**  
   * 计算两个数组的交集。  
   *  
   * @param {int[]} nums1 - 第一个整数数组  
   * @param {int[]} nums2 - 第二个整数数组  
   * @return {int[]} 两个数组的交集  
   */  
  public int[] intersection(int[] nums1, int[] nums2) {  
    // 如果 nums1 的长度大于 nums2 的长度，则交换两个数组，确保 nums1 是较短的那个  
    if (nums1.length > nums2.length) return intersection(nums2, nums1);  
  
    // 创建一个 HashSet 来存储 nums1 中的所有元素  
    final Set<Integer> table = new HashSet<>(nums1.length);  
    for (int num : nums1) {  
      // 将 nums1 中的每个元素添加到 HashSet 中  
      table.add(num);  
    }  
  
    // 创建另一个 HashSet 来存储交集结果  
    final Set<Integer> ans = new HashSet<>();  
    for (int num : nums2) {  
      // 检查 nums2 中的每个元素是否在 nums1 的 HashSet 中  
      if (table.contains(num)) {  
        // 如果存在，则将该元素添加到结果 HashSet 中  
        ans.add(num);  
      }  
    }  
      
    // 将结果 HashSet 转换为 int 数组并返回  
    return ans.stream().mapToInt(Integer::intValue).toArray();  
  }  
}
```

时间复杂度：$O (m+n)$，其中 $m$ 和 $n$ 分别是两个数组的长度。使用两个集合分别存储两个数组中的元素需要 $O(m+n)$ 的时间，遍历较小的集合并判断元素是否在另一个集合中需要 $O(min(m, n))$ 的时间，因此总时间复杂度是 $O(m+n)$。

空间复杂度：$O(m+n)$，其中 $m$ 和 $n$ 分别是两个数组的长度。空间复杂度主要取决于两个集合。
