---
tags:
  - LeetCode
  - Algorithm
level: Easy
categories:
  - 数组
  - 二分查找
create_time: 2025/08/14 19:06
update_time: 2025/08/14 23:41
---

## 题目描述

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target`，写一个函数搜索 `nums` 中的 `target`，如果 `target` 存在返回下标，否则返回 `-1`。

你必须编写一个具有 `O(log n)` 时间复杂度的算法。

**示例 1:**

```text
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例 2:**

```text
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

**提示：**

1. 你可以假设 `nums` 中的所有元素是不重复的。
2. `n` 将在 `[1, 10000]` 之间。
3. `nums` 的每个元素都将在 `[-9999, 9999]` 之间。

## 解法

### 方法一：左闭右闭

#### 解题思路

![](https://img.xiaorang.fun/202508142341133.gif)

#### 完整答案

```java
class Solution {
  public int search(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while(left <= right) {
      int mid = left + (right - left) / 2;
      int num = nums[mid];
      if(num == target) {
        return mid;
      } else if(num > target) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    }
    return -1;
  }
}
```

### 方法一：左闭右开

#### 解题思路

#### 完整答案

```java
class Solution {
  public int search(int[] nums, int target) {
    int left = 0, right = nums.length;
    while(left < right) {
      int mid = left + (right - left) / 2;
      int num = nums[mid];
      if(num == target) {
        return mid;
      } else if(num > target) {
        right = mid;
      } else {
        left = mid + 1;
      }
    }
    return -1;
  }
}
```
