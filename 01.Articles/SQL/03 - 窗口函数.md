---
tags:
  - SQL
create_time: 2025-03-23T22:54:00
update_time: 2025/04/04 21:38
repository: https://github.com/xihuanxiaorang/mysql-study/tree/main/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0
---

SQL 窗口函数广泛应用于在线分析处理（OLAP）和商业智能（BI），用于统计累计销售额、分类排名、同比/环比分析等。相较于传统的聚合函数和分组操作，窗口函数在**保留所有原始数据**的同时，提供更灵活的计算方式，提高数据分析效率。

## 窗口函数 vs 聚合函数

### 核心区别

**窗口函数（Window Function）** 与 **聚合函数（Aggregate Function）** 都用于数据分析，但二者有本质区别：
- **聚合函数**：对一组数据进行计算，返回**单个值**，如 `SUM()`、`AVG()` 等。
- **窗口函数**：在**不合并行数据**的情况下，对每行计算结果，并返回**多个值**，**保留所有原始记录**。

![[SQL - 窗口函数 vs 聚合函数|900]]

> [!info] 区别总结
> - **聚合函数**：将同一分组内的多行数据汇总为单个结果。
> - **窗口函数**：保留所有原始数据，同时计算出额外的分析结果。在某些数据库中，窗口函数也称为在线分析处理（OLAP）函数或分析函数（Analytic Function）。

### 示例对比

以 `SUM()` 举例，直观对比 **聚合函数** 和 **窗口函数** 的不同。

#### 聚合函数

```sql
SELECT SUM(salary) AS '月薪总和'
FROM employee;
```

上述 `SUM()` 作为**聚合函数**使用时，会汇总所有员工的薪资，并返回一个总值，即所有员工的月薪总和。查询结果如下：

| 月薪总和 |
| :--- |
| 245800.00 |

#### 窗口函数

```sql
SELECT emp_name AS '员工姓名', SUM(salary) OVER () AS '月薪总和'
FROM employee;
```

上述 `SUM()` 作为**窗口函数**使用时，`OVER()` 表示对所有数据进行汇总，但不改变行数，每行都会显示相同的总薪资。查询结果如下：

| 员工姓名 | 月薪总和 |
| :--- | :--- |
| 刘备 | 245800.00 |
| 关羽 | 245800.00 |
| 张飞 | 245800.00 |
| 诸葛亮 | 245800.00 |
| 黄忠 | 245800.00 |
| 魏延 | 245800.00 |
| 孙尚香 | 245800.00 |
| 孙丫鬟 | 245800.00 |
| 赵云 | 245800.00 |
| 廖化 | 245800.00 |
| 关平 | 245800.00 |
| 赵氏 | 245800.00 |
| 关兴 | 245800.00 |
| 张苞 | 245800.00 |
| 赵统 | 245800.00 |
| 周仓 | 245800.00 |
| 马岱 | 245800.00 |
| 法正 | 245800.00 |
| 庞统 | 245800.00 |
| 蒋琬 | 245800.00 |
| 黄权 | 245800.00 |
| 糜竺 | 245800.00 |
| 邓芝 | 245800.00 |
| 简雍 | 245800.00 |
| 孙乾 | 245800.00 |

从上述示例可以看出，窗口函数的语法与聚合函数的区别在于，它包含 `OVER` 子句，该子句用于定义数据分析的**窗口**。

## 语法✨

完整的窗口函数语法如下：

```sql
window_function([expression]) OVER (
  [PARTITION BY 分组列1, 分组列2, ...]
  [ORDER BY 排序列1, 排序列2, ... [ASC | DESC]]
  [(ROWS | RANGE) BETWEEN 开始行 AND 结束行]
)
```

- `window_function` 是窗口函数的名称（如 `SUM()`、`RANK()` 等），`expression` 是可选的分析对象（字段或表达式）。
- `OVER()` 子句用于定义窗口，包含：
    - 分区 `PARTITION BY`（可选），按指定列分组。
    - 排序 `ORDER BY`（可选）：指定分区内的排序方式。
    - 窗口大小 `frame_clause`（可选）：指定滑动窗口大小。
        - `ROWS`：以行数为单位计算窗口偏移量
        - `RANGE`：以数值范围（如 10 天、5km 等）计算窗口偏移量

### 创建数据分区

`PARTITION BY` 用于在窗口函数中定义数据分区，类似于 `GROUP BY`，但不会合并行，而是**保留所有原始数据**。

- **指定分区**：窗口函数会针对每个分区单独进行计算。
- **未指定分区**：窗口函数会作用于整个数据集。

举个栗子：统计各部门的月薪合计。SQL 语句如下所示：

```sql hl:4
SELECT emp_name AS '员工姓名', 
       salary AS '月薪', 
       dept_id AS '部门编号', 
       SUM(salary) OVER (PARTITION BY dept_id) AS '部门合计'
FROM employee;
```

查询结果如下：

| 员工姓名 | 月薪 | 部门编号 | 部门合计 |
| :--- | :--- | :--- | :--- |
| 刘备 | 30000.00 | 1 | 80000.00 |
| 关羽 | 26000.00 | 1 | 80000.00 |
| 张飞 | 24000.00 | 1 | 80000.00 |
| 诸葛亮 | 24000.00 | 2 | 39500.00 |
| 黄忠 | 8000.00 | 2 | 39500.00 |
| 魏延 | 7500.00 | 2 | 39500.00 |
| 孙尚香 | 12000.00 | 3 | 18000.00 |
| 孙丫鬟 | 6000.00 | 3 | 18000.00 |
| 赵云 | 15000.00 | 4 | 68200.00 |
| 廖化 | 6500.00 | 4 | 68200.00 |
| 关平 | 6800.00 | 4 | 68200.00 |
| 赵氏 | 6600.00 | 4 | 68200.00 |
| 关兴 | 7000.00 | 4 | 68200.00 |
| 张苞 | 6500.00 | 4 | 68200.00 |
| 赵统 | 6000.00 | 4 | 68200.00 |
| 周仓 | 8000.00 | 4 | 68200.00 |
| 马岱 | 5800.00 | 4 | 68200.00 |
| 法正 | 10000.00 | 5 | 40100.00 |
| 庞统 | 4100.00 | 5 | 40100.00 |
| 蒋琬 | 4000.00 | 5 | 40100.00 |
| 黄权 | 4200.00 | 5 | 40100.00 |
| 糜竺 | 4300.00 | 5 | 40100.00 |
| 邓芝 | 4000.00 | 5 | 40100.00 |
| 简雍 | 4800.00 | 5 | 40100.00 |
| 孙乾 | 4700.00 | 5 | 40100.00 |

在 `PARTITION BY dept_id` 作用下：
- 同一部门的员工共享相同的部门合计（如刘备、关羽、张飞的 "部门合计" 均为 80000 = 30000 + 26000 + 24000）。
- 不会像 `GROUP BY` 那样合并行，仍保留所有员工记录。🏷️

> [!tip]
>
> `PARTITION BY` 选项让我们无需 `GROUP BY` 也能获取分组统计结果。若省略 `PARTITION BY`，则按**整个数据集**进行计算。

### 分区内排序

`ORDER BY` 在窗口函数 `OVER` 子句中用于指定**分区内的数据排序**，类似于普通查询的 `ORDER BY`，常用于计算排名。

举个栗子：统计员工在部门内的薪资排名。

```sql hl:4
SELECT emp_name AS '员工姓名',
       salary AS '月薪',
       dept_id AS '部门编号',
       RANK() OVER (PARTITION BY dept_id ORDER BY salary DESC) AS '部门排名'
FROM employee;
```

其中：

- `PARTITION BY dept_id` 按部门进行分区，每个部门独立排名。
- `ORDER BY salary DESC` 在每个部门内按月薪**从高到低**排序。
- `RANK()` 计算薪资排名（相同薪资并列）。

查询结果如下：

| 员工姓名 | 月薪 | 部门编号 | 部门排名 |
| :--- | :--- | :--- | :--- |
| 刘备 | 30000.00 | 1 | 1 |
| 关羽 | 26000.00 | 1 | 2 |
| 张飞 | 24000.00 | 1 | 3 |
| 诸葛亮 | 24000.00 | 2 | 1 |
| 黄忠 | 8000.00 | 2 | 2 |
| 魏延 | 7500.00 | 2 | 3 |
| 孙尚香 | 12000.00 | 3 | 1 |
| 孙丫鬟 | 6000.00 | 3 | 2 |
| 赵云 | 15000.00 | 4 | 1 |
| 周仓 | 8000.00 | 4 | 2 |
| 关兴 | 7000.00 | 4 | 3 |
| 关平 | 6800.00 | 4 | 4 |
| 赵氏 | 6600.00 | 4 | 5 |
| 廖化 | 6500.00 | 4 | 6 |
| 张苞 | 6500.00 | 4 | 6 |
| 赵统 | 6000.00 | 4 | 8 |
| 马岱 | 5800.00 | 4 | 9 |
| 法正 | 10000.00 | 5 | 1 |
| 简雍 | 4800.00 | 5 | 2 |
| 孙乾 | 4700.00 | 5 | 3 |
| 糜竺 | 4300.00 | 5 | 4 |
| 黄权 | 4200.00 | 5 | 5 |
| 庞统 | 4100.00 | 5 | 6 |
| 蒋琬 | 4000.00 | 5 | 7 |
| 邓芝 | 4000.00 | 5 | 7 |

由查询结果可知，在部门一中 "刘备" 的月薪最高，"关羽" 第二; "张飞" 第三。

> [!tip]
>
> `ORDER BY` 既可用于普通查询，也可用于窗口函数。在 Oracle、PostgreSQL、SQLite 中，可加 `NULLS FIRST` 或 `NULLS LAST` 控制空值排序。

### 指定窗口大小

`OVER` 子句中的 `frame_clause` 定义**滑动分析窗口**，**窗口始终位于分区范围内，是分区的一个子集**。指定分析窗口后，窗口函数仅计算窗口内的数据，而非整个分区。

常见应用：
- **累积求和**（到当前日期为止的总销售额）
- **移动平均**（当前月及前后 N 个月的平均值）

窗口大小的指定方式：

```sql
{ ROWS | RANGE } frame_start
{ ROWS | RANGE } BETWEEN frame_start AND frame_end
```

- **`ROWS`**：按**行数**计算偏移量
- **`RANGE`**：按**数值范围**（如 10 天、5km）计算偏移量

窗口起始位置 (`frame_start`)
- `UNBOUNDED PRECEDING`：从**分区首行**开始（缺省默认值）
- `N PRECEDING`：从**当前行的前 N 行**开始
- `CURRENT ROW`：从**当前行**开始

窗口结束位置 (`frame_end`)
- `CURRENT ROW`：到**当前行**结束（缺省默认值）
- `M FOLLOWING`：到**当前行的后 M 行**结束
- `UNBOUNDED FOLLOWING`：到**分区最后一行**结束

下图展示了各选项的含义：
![[SQL - 窗口函数 - 窗口大小选项|600]]

在窗口函数分析每一行数据时，上图中的 `CURRENT ROW` 代表当前正在处理的行，其他行则根据其相对位置进行计算。

举个栗子：

```sql
ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
```

表示窗口从当前分区的第一行开始，到当前行结束。

> [!note]
> **分析窗口的大小不会超出分区范围**。部分窗口函数（如 `RANK()` 等排名窗口函数）不支持动态窗口大小，而是默认以整个分区作为分析窗口。

## 分类

窗口函数主要分为以下几类：

1. **聚合窗口函数**（Aggregate Window Function）：支持 `AVG()`、`SUM()`、`COUNT()`、`MAX()`、`MIN()` 等常见聚合函数。
2. **排名窗口函数**（Ranking Window Function）：用于分组排名。
   - **`ROW_NUMBER()`**：为分区内的每行数据分配唯一且连续的序号（1,2,3,...）。
   - **`RANK ()`**：返回当前行在分区中的排名，相同排名会跳跃（1,2,2,4,...）。
   - **`DENSE_RANK ()`**：返回当前行在分区中的排名，相同排名不跳跃（1,2,2,3,...）。
   - **`PERCENT_RANK ()`**：以百分比形式返回当前行在分区中的排名，相同排名会跳跃。
   - **`CUME_DIST ()`**：计算当前行在分区内的累计分布值。
   - **`NTILE (N)`**：将分区内数据等分为 N 份，返回当前行所在的分组编号。
3. **取值窗口函数**（Value Window Function）：用于获取窗口内特定位置的数据。
	- **`LAG (field, num, default)`**：返回当前行的前第 `num` 行数据。
	  - `field`（选择的字段）
	  - `num`（偏移量）
	  - `default`（默认值，即无数据时的填充值）。
	- **`LEAD (field, num, default)`**：返回当前行的后第 `num` 行数据。参数同 `LAG ()`。
	- **`FIRST_VALUE (field)`**：返回窗口内的第一行数据。
	- **`LAST_VALUE (field)`**：返回窗口内的最后一行数据。
	- **`NTH_VALUE (field, N)`**：返回窗口内的第 `N` 行数据。

> [!warning]
> `RANK ()`、`DENSE_RANK ()`、`ROW_NUMBER ()` 等排名函数以及 `LAG ()` 和 `LEAD ()` 函数不支持动态窗口大小，默认以整个分区作为分析窗口！！！

### 准备工作

- `sales_monthly`（月度销售表）：记录不同产品（苹果、香蕉、桔子）每月的销售额。

	```sql file:月度销售表
	DROP TABLE IF EXISTS sales_monthly;
	CREATE TABLE IF NOT EXISTS sales_monthly (
	    product VARCHAR(20),  -- 产品名称  
	    ym VARCHAR(10),       -- 年月  
	    amount NUMERIC(10,2)  -- 销售金额（元）  
	);
	
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('苹果','201801',10159.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('苹果','201802',10211.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('苹果','201803',10247.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('苹果','201804',10376.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('苹果','201805',10400.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('苹果','201806',10565.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('苹果','201807',10613.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('苹果','201808',10696.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('苹果','201809',10751.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('苹果','201810',10842.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('苹果','201811',10900.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('苹果','201812',10972.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('苹果','201901',11155.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('苹果','201902',11202.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('苹果','201903',11260.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('苹果','201904',11341.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('苹果','201905',11459.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('苹果','201906',11560.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('香蕉','201801',10138.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('香蕉','201802',10194.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('香蕉','201803',10328.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('香蕉','201804',10322.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('香蕉','201805',10481.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('香蕉','201806',10502.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('香蕉','201807',10589.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('香蕉','201808',10681.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('香蕉','201809',10798.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('香蕉','201810',10829.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('香蕉','201811',10913.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('香蕉','201812',11056.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('香蕉','201901',11161.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('香蕉','201902',11173.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('香蕉','201903',11288.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('香蕉','201904',11408.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('香蕉','201905',11469.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('香蕉','201906',11528.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('桔子','201801',10154.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('桔子','201802',10183.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('桔子','201803',10245.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('桔子','201804',10325.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('桔子','201805',10465.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('桔子','201806',10505.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('桔子','201807',10578.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('桔子','201808',10680.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('桔子','201809',10788.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('桔子','201810',10838.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('桔子','201811',10942.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('桔子','201812',10988.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('桔子','201901',11099.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('桔子','201902',11181.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('桔子','201903',11302.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('桔子','201904',11327.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('桔子','201905',11423.00);
	INSERT INTO sales_monthly (product,ym,amount) VALUES ('桔子','201906',11524.00);
	```

- `transfer_log`（银行交易日志表）：记录银行账户的交易日志，包括存款和转账。

	```sql file:银行交易日志表
	DROP TABLE IF EXISTS transfer_log;
	CREATE TABLE IF NOT EXISTS transfer_log (
	    log_id INTEGER PRIMARY KEY,  -- 交易日志编号  
	    log_ts TIMESTAMP NOT NULL,   -- 交易时间  
	    from_user VARCHAR(50) NOT NULL, -- 交易发起账号  
	    to_user VARCHAR(50),         -- 交易接收账号（存款时为空）  
	    type VARCHAR(10) NOT NULL,   -- 交易类型（存款/转账）  
	    amount NUMERIC(10) NOT NULL  -- 交易金额（元）  
	);
	
	INSERT INTO transfer_log (log_id,log_ts,from_user,to_user,type,amount) VALUES (1,'2021-01-02 10:31:40','62221234567890',NULL,'存款',50000);
	INSERT INTO transfer_log (log_id,log_ts,from_user,to_user,type,amount) VALUES (2,'2021-01-02 10:32:15','62221234567890',NULL,'存款',100000);
	INSERT INTO transfer_log (log_id,log_ts,from_user,to_user,type,amount) VALUES (3,'2021-01-03 08:14:29','62221234567890','62226666666666','转账',200000);
	INSERT INTO transfer_log (log_id,log_ts,from_user,to_user,type,amount) VALUES (4,'2021-01-05 13:55:38','62221234567890','62226666666666','转账',150000);
	INSERT INTO transfer_log (log_id,log_ts,from_user,to_user,type,amount) VALUES (5,'2021-01-07 20:00:31','62221234567890','62227777777777','转账',300000);
	INSERT INTO transfer_log (log_id,log_ts,from_user,to_user,type,amount) VALUES (6,'2021-01-09 17:28:07','62221234567890','62227777777777','转账',500000);
	INSERT INTO transfer_log (log_id,log_ts,from_user,to_user,type,amount) VALUES (7,'2021-01-10 07:46:02','62221234567890','62227777777777','转账',100000);
	INSERT INTO transfer_log (log_id,log_ts,from_user,to_user,type,amount) VALUES (8,'2021-01-11 09:36:53','62221234567890',NULL,'存款',40000);
	INSERT INTO transfer_log (log_id,log_ts,from_user,to_user,type,amount) VALUES (9,'2021-01-12 07:10:01','62221234567890','62228888888881','转账',10000);
	INSERT INTO transfer_log (log_id,log_ts,from_user,to_user,type,amount) VALUES (10,'2021-01-12 07:11:12','62221234567890','62228888888882','转账',8000);
	INSERT INTO transfer_log (log_id,log_ts,from_user,to_user,type,amount) VALUES (11,'2021-01-12 07:12:36','62221234567890','62228888888883','转账',5000);
	INSERT INTO transfer_log (log_id,log_ts,from_user,to_user,type,amount) VALUES (12,'2021-01-12 07:13:55','62221234567890','62228888888884','转账',6000);
	INSERT INTO transfer_log (log_id,log_ts,from_user,to_user,type,amount) VALUES (13,'2021-01-12 07:14:24','62221234567890','62228888888885','转账',7000);
	INSERT INTO transfer_log (log_id,log_ts,from_user,to_user,type,amount) VALUES (14,'2021-01-21 12:11:16','62221234567890','62228888888885','转账',70000);
	```

### 聚合窗口函数

#### 移动平均值

计算每种产品在最近 3 个月的平均销售额：

```sql
-- 查询最近 3 个月的平均销售额  
SELECT product                                                                                      AS '产品',  
       ym                                                                                           AS '年月',  
       amount                                                                                       AS '销售额',  
       AVG(amount) OVER (PARTITION BY product ORDER BY ym ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS '最近3个月的平均销售额'  
FROM sales_monthly;
```

- `PARTITION BY product` 按产品进行分区，确保计算不会跨产品。
- `ORDER BY ym`：按年月排序，保证计算按时间顺序进行。
- `ROWS BETWEEN 2 PRECEDING AND CURRENT ROW` 设定窗口为当前行及其前 2 行，实现 3 个月移动平均。

查询结果如下：

| 产品  | 年月     | 销售额      | 最近 3 个月的平均销售额 |
| :-- | :----- | :------- | :------------ |
| 桔子  | 201801 | 10154.00 | 10154.000000  |
| 桔子  | 201802 | 10183.00 | 10168.500000  |
| 桔子  | 201803 | 10245.00 | 10194.000000  |
| 桔子  | 201804 | 10325.00 | 10251.000000  |
| 桔子  | 201805 | 10465.00 | 10345.000000  |
| 桔子  | 201806 | 10505.00 | 10431.666667  |
| 桔子  | 201807 | 10578.00 | 10516.000000  |
| 桔子  | 201808 | 10680.00 | 10587.666667  |
| 桔子  | 201809 | 10788.00 | 10682.000000  |
| 桔子  | 201810 | 10838.00 | 10768.666667  |
| 桔子  | 201811 | 10942.00 | 10856.000000  |
| 桔子  | 201812 | 10988.00 | 10922.666667  |
| 桔子  | 201901 | 11099.00 | 11009.666667  |
| 桔子  | 201902 | 11181.00 | 11089.333333  |
| 桔子  | 201903 | 11302.00 | 11194.000000  |
| 桔子  | 201904 | 11327.00 | 11270.000000  |
| 桔子  | 201905 | 11423.00 | 11350.666667  |
| 桔子  | 201906 | 11524.00 | 11424.666667  |
| 苹果  | 201801 | 10159.00 | 10159.000000  |
| 苹果  | 201802 | 10211.00 | 10185.000000  |
| 苹果  | 201803 | 10247.00 | 10205.666667  |
| 苹果  | 201804 | 10376.00 | 10278.000000  |
| 苹果  | 201805 | 10400.00 | 10341.000000  |
| 苹果  | 201806 | 10565.00 | 10447.000000  |
| 苹果  | 201807 | 10613.00 | 10526.000000  |
| 苹果  | 201808 | 10696.00 | 10624.666667  |
| 苹果  | 201809 | 10751.00 | 10686.666667  |
| 苹果  | 201810 | 10842.00 | 10763.000000  |
| 苹果  | 201811 | 10900.00 | 10831.000000  |
| 苹果  | 201812 | 10972.00 | 10904.666667  |
| 苹果  | 201901 | 11155.00 | 11009.000000  |
| 苹果  | 201902 | 11202.00 | 11109.666667  |
| 苹果  | 201903 | 11260.00 | 11205.666667  |
| 苹果  | 201904 | 11341.00 | 11267.666667  |
| 苹果  | 201905 | 11459.00 | 11353.333333  |
| 苹果  | 201906 | 11560.00 | 11453.333333  |
| 香蕉  | 201801 | 10138.00 | 10138.000000  |
| 香蕉  | 201802 | 10194.00 | 10166.000000  |
| 香蕉  | 201803 | 10328.00 | 10220.000000  |
| 香蕉  | 201804 | 10322.00 | 10281.333333  |
| 香蕉  | 201805 | 10481.00 | 10377.000000  |
| 香蕉  | 201806 | 10502.00 | 10435.000000  |
| 香蕉  | 201807 | 10589.00 | 10524.000000  |
| 香蕉  | 201808 | 10681.00 | 10590.666667  |
| 香蕉  | 201809 | 10798.00 | 10689.333333  |
| 香蕉  | 201810 | 10829.00 | 10769.333333  |
| 香蕉  | 201811 | 10913.00 | 10846.666667  |
| 香蕉  | 201812 | 11056.00 | 10932.666667  |
| 香蕉  | 201901 | 11161.00 | 11043.333333  |
| 香蕉  | 201902 | 11173.00 | 11130.000000  |
| 香蕉  | 201903 | 11288.00 | 11207.333333  |
| 香蕉  | 201904 | 11408.00 | 11289.666667  |
| 香蕉  | 201905 | 11469.00 | 11388.333333  |
| 香蕉  | 201906 | 11528.00 | 11468.333333  |

- 第一行（`201801`）仅有 1 个月数据，因此平均值等于自身。
- 第二行（`201802`）计算前 2 个月的平均值 $(10154+10183)/2 = 10168.5$。
- 第三行（`201803`）及后续行都包含 3 个月数据，可以计算完整 3 个月的移动平均值 $(10154+10183+10245)/3 = 10194$。

#### 累计求和

计算每种产品截至当前月份的累计销售额：

```sql
SELECT product                                                                                              AS '产品',  
       ym                                                                                                   AS '年月',  
       amount                                                                                               AS '销售额',  
       SUM(amount) OVER (PARTITION BY product ORDER BY ym ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS '累计销售额'  
FROM sales_monthly;
```

- `PARTITION BY product` 按产品分区，确保计算仅在各自产品范围内进行。
- `ORDER BY ym` 按年月排序，保证计算按时间顺序累加。
- `ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW` 设定窗口从分区首行开始，到当前行结束，形成累计求和。

查询结果如下：

| 产品 | 年月 | 销售额 | 累计销售额 |
| :--- | :--- | :--- | :--- |
| 桔子 | 201801 | 10154.00 | 10154.00 |
| 桔子 | 201802 | 10183.00 | 20337.00 |
| 桔子 | 201803 | 10245.00 | 30582.00 |
| 桔子 | 201804 | 10325.00 | 40907.00 |
| 桔子 | 201805 | 10465.00 | 51372.00 |
| 桔子 | 201806 | 10505.00 | 61877.00 |
| 桔子 | 201807 | 10578.00 | 72455.00 |
| 桔子 | 201808 | 10680.00 | 83135.00 |
| 桔子 | 201809 | 10788.00 | 93923.00 |
| 桔子 | 201810 | 10838.00 | 104761.00 |
| 桔子 | 201811 | 10942.00 | 115703.00 |
| 桔子 | 201812 | 10988.00 | 126691.00 |
| 桔子 | 201901 | 11099.00 | 137790.00 |
| 桔子 | 201902 | 11181.00 | 148971.00 |
| 桔子 | 201903 | 11302.00 | 160273.00 |
| 桔子 | 201904 | 11327.00 | 171600.00 |
| 桔子 | 201905 | 11423.00 | 183023.00 |
| 桔子 | 201906 | 11524.00 | 194547.00 |
| 苹果 | 201801 | 10159.00 | 10159.00 |
| 苹果 | 201802 | 10211.00 | 20370.00 |
| 苹果 | 201803 | 10247.00 | 30617.00 |
| 苹果 | 201804 | 10376.00 | 40993.00 |
| 苹果 | 201805 | 10400.00 | 51393.00 |
| 苹果 | 201806 | 10565.00 | 61958.00 |
| 苹果 | 201807 | 10613.00 | 72571.00 |
| 苹果 | 201808 | 10696.00 | 83267.00 |
| 苹果 | 201809 | 10751.00 | 94018.00 |
| 苹果 | 201810 | 10842.00 | 104860.00 |
| 苹果 | 201811 | 10900.00 | 115760.00 |
| 苹果 | 201812 | 10972.00 | 126732.00 |
| 苹果 | 201901 | 11155.00 | 137887.00 |
| 苹果 | 201902 | 11202.00 | 149089.00 |
| 苹果 | 201903 | 11260.00 | 160349.00 |
| 苹果 | 201904 | 11341.00 | 171690.00 |
| 苹果 | 201905 | 11459.00 | 183149.00 |
| 苹果 | 201906 | 11560.00 | 194709.00 |
| 香蕉 | 201801 | 10138.00 | 10138.00 |
| 香蕉 | 201802 | 10194.00 | 20332.00 |
| 香蕉 | 201803 | 10328.00 | 30660.00 |
| 香蕉 | 201804 | 10322.00 | 40982.00 |
| 香蕉 | 201805 | 10481.00 | 51463.00 |
| 香蕉 | 201806 | 10502.00 | 61965.00 |
| 香蕉 | 201807 | 10589.00 | 72554.00 |
| 香蕉 | 201808 | 10681.00 | 83235.00 |
| 香蕉 | 201809 | 10798.00 | 94033.00 |
| 香蕉 | 201810 | 10829.00 | 104862.00 |
| 香蕉 | 201811 | 10913.00 | 115775.00 |
| 香蕉 | 201812 | 11056.00 | 126831.00 |
| 香蕉 | 201901 | 11161.00 | 137992.00 |
| 香蕉 | 201902 | 11173.00 | 149165.00 |
| 香蕉 | 201903 | 11288.00 | 160453.00 |
| 香蕉 | 201904 | 11408.00 | 171861.00 |
| 香蕉 | 201905 | 11469.00 | 183330.00 |
| 香蕉 | 201906 | 11528.00 | 194858.00 |

- 第一行（`201801`）仅有 1 个月数据，因此累计销售额等于自身。
- 第二行（`201802`）计算前 2 个月的累计销售额 $10154+10183 = 20337$。
- 第三行（`201803`）计算前 3 个月的累计销售额 $10154+10183+10245 = 30582$，以此类推。

> [!tip]
> 在聚合窗口函数中，
> - **若不指定 `ORDER BY` 选项，默认窗口大小为整个分区**。
> - **若指定 `ORDER BY` 选项，默认窗口从分区首行到当前行**，因此 `ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW` 可省略。

除了 `ROWS` 以数据行为单位，还可以使用 `RANGE` 以数值范围指定窗口。例如，查询 5 天内累计转账超 100 万元的账户：

```sql
WITH t AS (SELECT log_ts,  
                  from_user,  
                  SUM(amount)  
                      OVER (PARTITION BY from_user ORDER BY log_ts RANGE INTERVAL '5' DAY PRECEDING) AS total_amount  
           FROM transfer_log  
           WHERE type = '转账')  
SELECT *  
FROM t  
WHERE total_amount > 1000000;
```

- `RANGE INTERVAL '5' DAY PRECEDING`：等价于 `RANGE BETWEEN INTERVAL '5' DAY PRECEDING AND CURRENT ROW`，设定一个以时间为单位的滚动窗口，计算 5 天内的累计转账金额。
- `PARTITION BY from_user`：按账户分区，确保每个账户的计算互不影响。
- `ORDER BY log_ts`：按交易时间排序，确保计算遵循时间顺序。

> [!tip]
> 由于 **`RANGE` 依赖 `ORDER BY` 指定字段**，`ORDER BY log_ts` 使窗口计算基于时间范围而非数据行数。

查询结果如下：

| log\_ts             | from\_user     | total\_amount |
| :------------------ | :------------- | :------------ |
| 2021-01-10 07:46:02 | 62221234567890 | 1050000       |

### 排名窗口函数

#### 分类排名

查询每个员工在其部门内的月薪排名：

```sql  
SELECT d.dept_name                                                         AS '部门名称',  
       e.emp_name                                                          AS '姓名',  
       e.salary                                                            AS '月薪',  
       ROW_NUMBER() OVER (PARTITION BY d.dept_id ORDER BY e.salary DESC)   AS 'row_number',  
       RANK() OVER (PARTITION BY d.dept_id ORDER BY e.salary DESC)         AS 'rank',  
       DENSE_RANK() OVER (PARTITION BY d.dept_id ORDER BY e.salary DESC)   AS 'dense_rank',  
       PERCENT_RANK() OVER (PARTITION BY d.dept_id ORDER BY e.salary DESC) AS 'percent_rank'  
FROM employee e  
         JOIN department d on e.dept_id = d.dept_id;
```

- `PARTITION BY e.dept_id`：按部门分区，每个部门独立排名。
- `ORDER BY e.salary DESC`：按月薪降序排列，薪资高者排名靠前。

查询结果如下：

| 部门名称 | 姓名 | 月薪 | row\_number | rank | dense\_rank | percent\_rank |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 行政管理部 | 刘备 | 30000.00 | 1 | 1 | 1 | 0 |
| 行政管理部 | 关羽 | 26000.00 | 2 | 2 | 2 | 0.5 |
| 行政管理部 | 张飞 | 24000.00 | 3 | 3 | 3 | 1 |
| 人力资源部 | 诸葛亮 | 24000.00 | 1 | 1 | 1 | 0 |
| 人力资源部 | 黄忠 | 8000.00 | 2 | 2 | 2 | 0.5 |
| 人力资源部 | 魏延 | 7500.00 | 3 | 3 | 3 | 1 |
| 财务部 | 孙尚香 | 12000.00 | 1 | 1 | 1 | 0 |
| 财务部 | 孙丫鬟 | 6000.00 | 2 | 2 | 2 | 1 |
| 研发部 | 赵云 | 15000.00 | 1 | 1 | 1 | 0 |
| 研发部 | 周仓 | 8000.00 | 2 | 2 | 2 | 0.125 |
| 研发部 | 关兴 | 7000.00 | 3 | 3 | 3 | 0.25 |
| 研发部 | 关平 | 6800.00 | 4 | 4 | 4 | 0.375 |
| 研发部 | 赵氏 | 6600.00 | 5 | 5 | 5 | 0.5 |
| 研发部 | 廖化 | 6500.00 | 6 | 6 | 6 | 0.625 |
| 研发部 | 张苞 | 6500.00 | 7 | 6 | 6 | 0.625 |
| 研发部 | 赵统 | 6000.00 | 8 | 8 | 7 | 0.875 |
| 研发部 | 马岱 | 5800.00 | 9 | 9 | 8 | 1 |
| 销售部 | 法正 | 10000.00 | 1 | 1 | 1 | 0 |
| 销售部 | 简雍 | 4800.00 | 2 | 2 | 2 | 0.14285714285714285 |
| 销售部 | 孙乾 | 4700.00 | 3 | 3 | 3 | 0.2857142857142857 |
| 销售部 | 糜竺 | 4300.00 | 4 | 4 | 4 | 0.42857142857142855 |
| 销售部 | 黄权 | 4200.00 | 5 | 5 | 5 | 0.5714285714285714 |
| 销售部 | 庞统 | 4100.00 | 6 | 6 | 6 | 0.7142857142857143 |
| 销售部 | 蒋琬 | 4000.00 | 7 | 7 | 7 | 0.8571428571428571 |
| 销售部 | 邓芝 | 4000.00 | 8 | 7 | 7 | 0.8571428571428571 |

以 "研发部" 为例：
- `ROW_NUMBER ()`：分配连续编号，"廖化" 和 "张苞" 月薪相同，但编号不同。
- `RANK ()`：相同月薪排名相同，后续排名跳跃（"廖化" 和 "张苞" 并列第 6，"赵统" 排第 8）。
- `DENSE_RANK ()`：相同月薪排名相同，后续排名不跳跃（"廖化" 和 "张苞" 并列第 6，"赵统" 排第 7）。
- `PERCENT_RANK ()`：计算相对排名百分比，范围 0 到 1，其中 "赵统" 的排名为 0.875，存在跳跃。

> [!tip]
> `COUNT ()` 聚合窗口函数可实现与 `ROW_NUMBER ()` 相同的效果。

以上示例中，4 个窗口函数的 `OVER` 子句完全相同，此时可用 `WINDOW` 子句简化写法：

```sql
SELECT d.dept_name           AS '部门名称',  
       e.emp_name            AS '姓名',  
       e.salary              AS '月薪',  
       ROW_NUMBER() OVER w   AS 'row_number',  
       RANK() OVER w         AS 'rank',  
       DENSE_RANK() OVER w   AS 'dense_rank',  
       PERCENT_RANK() OVER w AS 'percent_rank'  
FROM employee e  
         JOIN department d ON e.dept_id = d.dept_id  
WINDOW w AS (PARTITION BY e.dept_id ORDER BY e.salary DESC);
```

`WINDOW` 子句定义了窗口变量 `w`，并在所有 `OVER` 子句中复用，使语句更简洁。该查询返回的结果与前述示例相同。此语法尚不支持 Oracle 和 Microsoft SQL Server。

#### Top-N 排行榜

基于排名窗口函数，还可实现分类 **Top-N 排行榜**，如查询每个部门入职最早的 2 名员工：

```sql 
WITH ranked_emp AS (SELECT d.dept_name,  
                           e.emp_name,  
                           e.hire_date,  
                           ROW_NUMBER() OVER (PARTITION BY d.dept_id ORDER BY e.hire_date) AS 'rn'  
                    FROM employee e  
                             JOIN department d ON e.dept_id = d.dept_id)  
SELECT dept_name AS '部门名称', emp_name AS '姓名', hire_date AS '入职日期', rn AS '入职顺序'  
FROM ranked_emp  
WHERE rn <= 2;
```

`ranked_emp` 作为 [[02 - 通用表表达式]]（CTE），计算每个员工在本部门的入职顺序，最终查询前 2 名入职员工。查询结果如下：

| 部门名称  | 姓名  | 入职日期       | 入职顺序 |
| :---- | :-- | :--------- | :--- |
| 行政管理部 | 刘备  | 2000-01-01 | 1    |
| 行政管理部 | 关羽  | 2000-01-01 | 2    |
| 人力资源部 | 诸葛亮 | 2006-03-15 | 1    |
| 人力资源部 | 魏延  | 2007-04-01 | 2    |
| 财务部   | 孙尚香 | 2002-08-08 | 1    |
| 财务部   | 孙丫鬟 | 2002-08-08 | 2    |
| 研发部   | 赵云  | 2005-12-19 | 1    |
| 研发部   | 廖化  | 2009-02-17 | 2    |
| 销售部   | 法正  | 2017-04-09 | 1    |
| 销售部   | 庞统  | 2017-06-06 | 2    |

#### 累计分布

`CUME_DIST ()` 计算当前行及之前所有行在分区内的累计分布比例，取值范围为 `(0, 1]`。

举个栗子：按月薪排序，计算所有员工的累计分布情况。

```sql
SELECT emp_name '姓名', salary '月薪', CUME_DIST() OVER (ORDER BY salary) '累计占比'  
FROM employee;
```

由于 `OVER` 子句未指定分区，`CUME_DIST ()` 会在全体员工范围内计算累计分布。查询结果如下：

| 姓名 | 月薪 | 累计占比 |
| :--- | :--- | :--- |
| 蒋琬 | 4000.00 | 0.08 |
| 邓芝 | 4000.00 | 0.08 |
| 庞统 | 4100.00 | 0.12 |
| 黄权 | 4200.00 | 0.16 |
| 糜竺 | 4300.00 | 0.2 |
| 孙乾 | 4700.00 | 0.24 |
| 简雍 | 4800.00 | 0.28 |
| 马岱 | 5800.00 | 0.32 |
| 孙丫鬟 | 6000.00 | 0.4 |
| 赵统 | 6000.00 | 0.4 |
| 廖化 | 6500.00 | 0.48 |
| 张苞 | 6500.00 | 0.48 |
| 赵氏 | 6600.00 | 0.52 |
| 关平 | 6800.00 | 0.56 |
| 关兴 | 7000.00 | 0.6 |
| 魏延 | 7500.00 | 0.64 |
| 黄忠 | 8000.00 | 0.72 |
| 周仓 | 8000.00 | 0.72 |
| 法正 | 10000.00 | 0.76 |
| 孙尚香 | 12000.00 | 0.8 |
| 赵云 | 15000.00 | 0.84 |
| 张飞 | 24000.00 | 0.92 |
| 诸葛亮 | 24000.00 | 0.92 |
| 关羽 | 26000.00 | 0.96 |
| 刘备 | 30000.00 | 1 |

结果显示，月薪 4000 元的员工累计占比 0.08，表示公司 8% 的员工月薪 ≤ 4000 元。

#### 分组排名

`NTILE (N)` 用于将数据均分为 `N` 组，并计算当前行所属的分组。

举个栗子：按入职时间排序，将员工分为 5 组, 计算每个员工所在分组。

```sql
SELECT emp_name AS '姓名', hire_date AS '入职日期', NTILE(5) OVER (ORDER BY hire_date) AS '分组位置'  
FROM employee;
```

`OVER` 子句未指定分区，`NTILE ()` 会在全体员工范围内计算分组。查询结果如下：

| 姓名 | 入职日期 | 分组位置 |
| :--- | :--- | :--- |
| 刘备 | 2000-01-01 | 1 |
| 关羽 | 2000-01-01 | 1 |
| 张飞 | 2000-01-01 | 1 |
| 孙尚香 | 2002-08-08 | 1 |
| 孙丫鬟 | 2002-08-08 | 1 |
| 赵云 | 2005-12-19 | 2 |
| 诸葛亮 | 2006-03-15 | 2 |
| 魏延 | 2007-04-01 | 2 |
| 黄忠 | 2008-10-25 | 2 |
| 廖化 | 2009-02-17 | 2 |
| 周仓 | 2010-02-20 | 3 |
| 关平 | 2011-07-24 | 3 |
| 关兴 | 2011-07-30 | 3 |
| 赵氏 | 2011-11-10 | 3 |
| 赵统 | 2012-05-03 | 3 |
| 张苞 | 2012-05-31 | 4 |
| 马岱 | 2014-09-16 | 4 |
| 法正 | 2017-04-09 | 4 |
| 庞统 | 2017-06-06 | 4 |
| 蒋琬 | 2018-01-28 | 4 |
| 黄权 | 2018-03-14 | 5 |
| 糜竺 | 2018-03-27 | 5 |
| 孙乾 | 2018-10-09 | 5 |
| 邓芝 | 2018-11-11 | 5 |
| 简雍 | 2019-05-11 | 5 |

结果显示，
- 分组 1：最早入职的 20% 员工。
- 分组 5：最晚入职的 20% 员工。

### 取值窗口函数

#### 环比增长

环比增长是指本期数据相较于上一期的增幅。例如，2019 年 6 月的销售额相较 2019 年 5 月的增长情况。

举个栗子：计算各产品的月度环比增长率。

> [!tip] 环比增长率计算公式
> $$
> \text{环比增长率 (\%) } = \frac{\text{当前月销售额} - \text{上月销售额}}{\text{上月销售额}} \times 100\%
> $$

```sql
SELECT product AS '产品',  
       ym      AS '年月',  
       amount  AS '销售额',  
       (amount - LAG(amount, 1) OVER (PARTITION BY product ORDER BY ym)) /  
       LAG(amount, 1) OVER (PARTITION BY product ORDER BY ym) *  
       100     AS '环比增长率(%)'  
FROM sales_monthly  
ORDER BY product, ym;
```

- `LAG (amount, 1)` 取上一期的销售额。
- `PARTITION BY product` 按产品分区。
- `ORDER BY ym` 按时间排序。

查询结果如下：

| 产品  | 年月     | 销售额      | 环比增长率\(%\) |
| :-- | :----- | :------- | :--------- |
| 桔子  | 201801 | 10154.00 | null       |
| 桔子  | 201802 | 10183.00 | 0.285602   |
| 桔子  | 201803 | 10245.00 | 0.608858   |
| 桔子  | 201804 | 10325.00 | 0.780869   |
| 桔子  | 201805 | 10465.00 | 1.355932   |
| 桔子  | 201806 | 10505.00 | 0.382226   |
| 桔子  | 201807 | 10578.00 | 0.694907   |
| 桔子  | 201808 | 10680.00 | 0.964265   |
| 桔子  | 201809 | 10788.00 | 1.011236   |
| 桔子  | 201810 | 10838.00 | 0.463478   |
| 桔子  | 201811 | 10942.00 | 0.959587   |
| 桔子  | 201812 | 10988.00 | 0.420398   |
| 桔子  | 201901 | 11099.00 | 1.010193   |
| 桔子  | 201902 | 11181.00 | 0.738805   |
| 桔子  | 201903 | 11302.00 | 1.082193   |
| 桔子  | 201904 | 11327.00 | 0.221200   |
| 桔子  | 201905 | 11423.00 | 0.847532   |
| 桔子  | 201906 | 11524.00 | 0.884181   |
| 苹果  | 201801 | 10159.00 | null       |
| 苹果  | 201802 | 10211.00 | 0.511861   |
| 苹果  | 201803 | 10247.00 | 0.352561   |
| 苹果  | 201804 | 10376.00 | 1.258905   |
| 苹果  | 201805 | 10400.00 | 0.231303   |
| 苹果  | 201806 | 10565.00 | 1.586538   |
| 苹果  | 201807 | 10613.00 | 0.454330   |
| 苹果  | 201808 | 10696.00 | 0.782060   |
| 苹果  | 201809 | 10751.00 | 0.514211   |
| 苹果  | 201810 | 10842.00 | 0.846433   |
| 苹果  | 201811 | 10900.00 | 0.534957   |
| 苹果  | 201812 | 10972.00 | 0.660550   |
| 苹果  | 201901 | 11155.00 | 1.667882   |
| 苹果  | 201902 | 11202.00 | 0.421336   |
| 苹果  | 201903 | 11260.00 | 0.517765   |
| 苹果  | 201904 | 11341.00 | 0.719361   |
| 苹果  | 201905 | 11459.00 | 1.040473   |
| 苹果  | 201906 | 11560.00 | 0.881403   |
| 香蕉  | 201801 | 10138.00 | null       |
| 香蕉  | 201802 | 10194.00 | 0.552377   |
| 香蕉  | 201803 | 10328.00 | 1.314499   |
| 香蕉  | 201804 | 10322.00 | -0.058095  |
| 香蕉  | 201805 | 10481.00 | 1.540399   |
| 香蕉  | 201806 | 10502.00 | 0.200363   |
| 香蕉  | 201807 | 10589.00 | 0.828414   |
| 香蕉  | 201808 | 10681.00 | 0.868826   |
| 香蕉  | 201809 | 10798.00 | 1.095403   |
| 香蕉  | 201810 | 10829.00 | 0.287090   |
| 香蕉  | 201811 | 10913.00 | 0.775695   |
| 香蕉  | 201812 | 11056.00 | 1.310364   |
| 香蕉  | 201901 | 11161.00 | 0.949711   |
| 香蕉  | 201902 | 11173.00 | 0.107517   |
| 香蕉  | 201903 | 11288.00 | 1.029267   |
| 香蕉  | 201904 | 11408.00 | 1.063076   |
| 香蕉  | 201905 | 11469.00 | 0.534712   |
| 香蕉  | 201906 | 11528.00 | 0.514430   |

结果显示，2018 年 1 月是第一期，因此环比增长率为空。"桔子" 2018 年 2 月的环比增长率约为 $0.29\% = \left (\frac{10183 - 10154}{10154}\right) \times 100$，其余月份依此类推。

#### 同比增长

同比增长指本期数据与上一年度同期相比的增幅。例如，2019 年 6 月的销售额与 2018 年 6 月相比的变化。

> [!tip] 同比增长率计算公式
> $$  
> \text{同比增长率 (\%) } = \frac{\text{当前月销售额} - \text{去年同期销售额}}{\text{去年同期销售额}} \times 100\%  
> $$  

举个栗子：计算各产品的月度同比增长率：

```sql
SELECT product AS '产品',  
       ym      AS '年月',  
       amount  AS '销售额',  
       (amount - LAG(amount, 12) OVER (PARTITION BY product ORDER BY ym)) /  
       LAG(amount, 12) OVER (PARTITION BY product ORDER BY ym) *  
       100     AS '同比增长率(%)'  
FROM sales_monthly  
ORDER BY product, ym;
```

- `LAG (amount, 12)` 取去年同期的销售额。
- `PARTITION BY product` 按产品分区。
- `ORDER BY ym` 按月份排序。

查询结果如下：

| 产品  | 年月     | 销售额      | 同比增长率\(%\) |
| :-- | :----- | :------- | :--------- |
| 桔子  | 201801 | 10154.00 | null       |
| 桔子  | 201802 | 10183.00 | null       |
| 桔子  | 201803 | 10245.00 | null       |
| 桔子  | 201804 | 10325.00 | null       |
| 桔子  | 201805 | 10465.00 | null       |
| 桔子  | 201806 | 10505.00 | null       |
| 桔子  | 201807 | 10578.00 | null       |
| 桔子  | 201808 | 10680.00 | null       |
| 桔子  | 201809 | 10788.00 | null       |
| 桔子  | 201810 | 10838.00 | null       |
| 桔子  | 201811 | 10942.00 | null       |
| 桔子  | 201812 | 10988.00 | null       |
| 桔子  | 201901 | 11099.00 | 9.306677   |
| 桔子  | 201902 | 11181.00 | 9.800648   |
| 桔子  | 201903 | 11302.00 | 10.317228  |
| 桔子  | 201904 | 11327.00 | 9.704600   |
| 桔子  | 201905 | 11423.00 | 9.154324   |
| 桔子  | 201906 | 11524.00 | 9.700143   |
| 苹果  | 201801 | 10159.00 | null       |
| 苹果  | 201802 | 10211.00 | null       |
| 苹果  | 201803 | 10247.00 | null       |
| 苹果  | 201804 | 10376.00 | null       |
| 苹果  | 201805 | 10400.00 | null       |
| 苹果  | 201806 | 10565.00 | null       |
| 苹果  | 201807 | 10613.00 | null       |
| 苹果  | 201808 | 10696.00 | null       |
| 苹果  | 201809 | 10751.00 | null       |
| 苹果  | 201810 | 10842.00 | null       |
| 苹果  | 201811 | 10900.00 | null       |
| 苹果  | 201812 | 10972.00 | null       |
| 苹果  | 201901 | 11155.00 | 9.804115   |
| 苹果  | 201902 | 11202.00 | 9.705220   |
| 苹果  | 201903 | 11260.00 | 9.885820   |
| 苹果  | 201904 | 11341.00 | 9.300308   |
| 苹果  | 201905 | 11459.00 | 10.182692  |
| 苹果  | 201906 | 11560.00 | 9.417889   |
| 香蕉  | 201801 | 10138.00 | null       |
| 香蕉  | 201802 | 10194.00 | null       |
| 香蕉  | 201803 | 10328.00 | null       |
| 香蕉  | 201804 | 10322.00 | null       |
| 香蕉  | 201805 | 10481.00 | null       |
| 香蕉  | 201806 | 10502.00 | null       |
| 香蕉  | 201807 | 10589.00 | null       |
| 香蕉  | 201808 | 10681.00 | null       |
| 香蕉  | 201809 | 10798.00 | null       |
| 香蕉  | 201810 | 10829.00 | null       |
| 香蕉  | 201811 | 10913.00 | null       |
| 香蕉  | 201812 | 11056.00 | null       |
| 香蕉  | 201901 | 11161.00 | 10.090748  |
| 香蕉  | 201902 | 11173.00 | 9.603688   |
| 香蕉  | 201903 | 11288.00 | 9.295120   |
| 香蕉  | 201904 | 11408.00 | 10.521217  |
| 香蕉  | 201905 | 11469.00 | 9.426581   |
| 香蕉  | 201906 | 11528.00 | 9.769568   |

结果显示，2018 年无同比数据，"桔子" 2019 年 1 月的同比增长率约为 $9.31\% = \left ( \frac{11099 - 10154}{10154} \right) \times 100$，其余月份依此类推。

#### 复合增长率

复合增长率表示数据随时间增长的平均速度，计算公式为：

$$
\text{复合增长率} = \left( \frac{\text{最终期销售额}}{\text{初始期销售额}} \right)^{\frac{1}{N-1}} - 1
$$
其中，$N$ 是时间间隔的期数。例如，假设某产品 2018 年销售额为 10,000，2019 年为 12,500，2020 年为 15,000，则两年的复合增长率计算如下：

$$
\left( \frac{15000}{10000} \right)^{\frac{1}{2}} - 1 = 22.47\%
$$

按时间单位分类：

- 年均复合增长率：以年度为单位计算
- 月均复合增长率：以月度为单位计算

举个栗子：计算自 2018 年 1 月以来不同产品的月均复合增长率。

```sql
-- 计算自 2018 年 1 月以来不同产品的月均复合增长率  
WITH s(product, ym, amount, first_amount, num) AS (SELECT product,  
                                                          ym,  
                                                          amount,  
                                                          FIRST_VALUE(amount) OVER (PARTITION BY product ORDER BY ym),  
                                                          ROW_NUMBER() OVER (PARTITION BY product ORDER BY ym)  
                                                   FROM sales_monthly)  
SELECT product AS                                                               '产品',  
       ym      AS                                                               '年月',  
       amount  AS                                                               '销售额',  
       (POWER(1.0 * amount / first_amount, 1.0 / NULLIF(num - 1, 0)) - 1) * 100 '月均复合销售率（%）'  
FROM s;
```

以 "桔子" 为例：
- `FIRST_VALUE (amount)` 获取第一期（201801）的销售额。
- `ROW_NUMBER ()` 计算当前数据是第几期。
- `POWER ()` 计算 N-1 次方根，实现复合增长率计算。
- `NULLIF (num - 1, 0)` 避免第一期数据出现除零错误。
- `1.0 * amount` 确保浮点计算，避免整数除法误差。

查询结果如下：

| 产品 | 年月 | 销售额 | 月均复合销售率（%） |
| :--- | :--- | :--- | :--- |
| 桔子 | 201801 | 10154.00 | null |
| 桔子 | 201802 | 10183.00 | 0.2856017333070726 |
| 桔子 | 201803 | 10245.00 | 0.44709978015609053 |
| 桔子 | 201804 | 10325.00 | 0.5582330899585486 |
| 桔子 | 201805 | 10465.00 | 0.7570673570692854 |
| 桔子 | 201806 | 10505.00 | 0.6819873698546308 |
| 桔子 | 201807 | 10578.00 | 0.6841405548516422 |
| 桔子 | 201808 | 10680.00 | 0.7241107615881148 |
| 桔子 | 201809 | 10788.00 | 0.7599567334352519 |
| 桔子 | 201810 | 10838.00 | 0.7269714845334896 |
| 桔子 | 201811 | 10942.00 | 0.7502088623154046 |
| 桔子 | 201812 | 10988.00 | 0.7201813848927152 |
| 桔子 | 201901 | 11099.00 | 0.7443171820965988 |
| 桔子 | 201902 | 11181.00 | 0.7438931740867183 |
| 桔子 | 201903 | 11302.00 | 0.7680198585853448 |
| 桔子 | 201904 | 11327.00 | 0.7314725430307867 |
| 桔子 | 201905 | 11423.00 | 0.7387223790708886 |
| 桔子 | 201906 | 11524.00 | 0.7472729569657055 |
| 苹果 | 201801 | 10159.00 | null |
| 苹果 | 201802 | 10211.00 | 0.5118614036814684 |
| 苹果 | 201803 | 10247.00 | 0.432179599392124 |
| 苹果 | 201804 | 10376.00 | 0.7070020377621056 |
| 苹果 | 201805 | 10400.00 | 0.5878660411253733 |
| 苹果 | 201806 | 10565.00 | 0.7868120035583903 |
| 苹果 | 201807 | 10613.00 | 0.731322068040785 |
| 苹果 | 201808 | 10696.00 | 0.7385687405051078 |
| 苹果 | 201809 | 10751.00 | 0.7104966528160617 |
| 苹果 | 201810 | 10842.00 | 0.7255916252433714 |
| 苹果 | 201811 | 10900.00 | 0.7065118729371989 |
| 苹果 | 201812 | 10972.00 | 0.7023326884637582 |
| 苹果 | 201901 | 11155.00 | 0.7824436777998489 |
| 苹果 | 201902 | 11202.00 | 0.7546200948467252 |
| 苹果 | 201903 | 11260.00 | 0.7376833619111567 |
| 苹果 | 201904 | 11341.00 | 0.7364617354021608 |
| 苹果 | 201905 | 11459.00 | 0.7554355959988657 |
| 苹果 | 201906 | 11560.00 | 0.7628410974228617 |
| 香蕉 | 201801 | 10138.00 | null |
| 香蕉 | 201802 | 10194.00 | 0.5523771947129719 |
| 香蕉 | 201803 | 10328.00 | 0.9327186350557293 |
| 香蕉 | 201804 | 10322.00 | 0.6013609469889936 |
| 香蕉 | 201805 | 10481.00 | 0.835303204318727 |
| 香蕉 | 201806 | 10502.00 | 0.7079940138587482 |
| 香蕉 | 201807 | 10589.00 | 0.7280539559113341 |
| 香蕉 | 201808 | 10681.00 | 0.7481522313370847 |
| 香蕉 | 201809 | 10798.00 | 0.7914932743322778 |
| 香蕉 | 201810 | 10829.00 | 0.7353234394735786 |
| 香蕉 | 201811 | 10913.00 | 0.7393598576287186 |
| 香蕉 | 201812 | 11056.00 | 0.7911360374552867 |
| 香蕉 | 201901 | 11161.00 | 0.8043410660433459 |
| 香蕉 | 201902 | 11173.00 | 0.7505674522999994 |
| 香蕉 | 201903 | 11288.00 | 0.7704490436124756 |
| 香蕉 | 201904 | 11408.00 | 0.789931105093733 |
| 香蕉 | 201905 | 11469.00 | 0.7739609841810768 |
| 香蕉 | 201906 | 11528.00 | 0.75867592930563 |

结果显示，2018 年 1 月是第一期，因此复合增长率为空。2018 年 2 月的月均复合增长率等于环比增长率，后续月份依此类推。

#### 各产品销售额关键月份查询

统计不同产品的最高、最低及第三高销售额所在的月份：

```sql
SELECT product                 AS '产品',  
       ym                      AS '年月',  
       amount                  AS '销售额',  
       FIRST_VALUE(ym) OVER w  AS '最高销售额月份',  
       LAST_VALUE(ym) OVER w   AS '最低销售额月份',  
       NTH_VALUE(ym, 3) OVER w AS '第三高销售额月份'  
FROM sales_monthly  
WINDOW w AS ( PARTITION BY product ORDER BY amount DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING )  
ORDER BY product, ym;
```

- `PARTITION BY product`：按产品分区，分别计算各产品的销售情况。
- `ORDER BY amount DESC`：按销售额从高到低排序。
- `FIRST_VALUE (ym) OVER w`：获取最高销售额对应的月份。
- `LAST_VALUE (ym) OVER w`：获取最低销售额对应的月份。
- `NTH_VALUE (ym, 3) OVER w`：获取第三高销售额对应的月份。
- `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`：扩展窗口范围至整个分区，确保获取全局的最高、最低和第三高销售额的月份。默认窗口仅覆盖分区首行至当前行，因此需显式指定完整窗口范围。

查询结果如下：

| 产品 | 年月 | 销售额 | 最高销售额月份 | 最低销售额月份 | 第三高销售额月份 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 桔子 | 201801 | 10154.00 | 201906 | 201801 | 201904 |
| 桔子 | 201802 | 10183.00 | 201906 | 201801 | 201904 |
| 桔子 | 201803 | 10245.00 | 201906 | 201801 | 201904 |
| 桔子 | 201804 | 10325.00 | 201906 | 201801 | 201904 |
| 桔子 | 201805 | 10465.00 | 201906 | 201801 | 201904 |
| 桔子 | 201806 | 10505.00 | 201906 | 201801 | 201904 |
| 桔子 | 201807 | 10578.00 | 201906 | 201801 | 201904 |
| 桔子 | 201808 | 10680.00 | 201906 | 201801 | 201904 |
| 桔子 | 201809 | 10788.00 | 201906 | 201801 | 201904 |
| 桔子 | 201810 | 10838.00 | 201906 | 201801 | 201904 |
| 桔子 | 201811 | 10942.00 | 201906 | 201801 | 201904 |
| 桔子 | 201812 | 10988.00 | 201906 | 201801 | 201904 |
| 桔子 | 201901 | 11099.00 | 201906 | 201801 | 201904 |
| 桔子 | 201902 | 11181.00 | 201906 | 201801 | 201904 |
| 桔子 | 201903 | 11302.00 | 201906 | 201801 | 201904 |
| 桔子 | 201904 | 11327.00 | 201906 | 201801 | 201904 |
| 桔子 | 201905 | 11423.00 | 201906 | 201801 | 201904 |
| 桔子 | 201906 | 11524.00 | 201906 | 201801 | 201904 |
| 苹果 | 201801 | 10159.00 | 201906 | 201801 | 201904 |
| 苹果 | 201802 | 10211.00 | 201906 | 201801 | 201904 |
| 苹果 | 201803 | 10247.00 | 201906 | 201801 | 201904 |
| 苹果 | 201804 | 10376.00 | 201906 | 201801 | 201904 |
| 苹果 | 201805 | 10400.00 | 201906 | 201801 | 201904 |
| 苹果 | 201806 | 10565.00 | 201906 | 201801 | 201904 |
| 苹果 | 201807 | 10613.00 | 201906 | 201801 | 201904 |
| 苹果 | 201808 | 10696.00 | 201906 | 201801 | 201904 |
| 苹果 | 201809 | 10751.00 | 201906 | 201801 | 201904 |
| 苹果 | 201810 | 10842.00 | 201906 | 201801 | 201904 |
| 苹果 | 201811 | 10900.00 | 201906 | 201801 | 201904 |
| 苹果 | 201812 | 10972.00 | 201906 | 201801 | 201904 |
| 苹果 | 201901 | 11155.00 | 201906 | 201801 | 201904 |
| 苹果 | 201902 | 11202.00 | 201906 | 201801 | 201904 |
| 苹果 | 201903 | 11260.00 | 201906 | 201801 | 201904 |
| 苹果 | 201904 | 11341.00 | 201906 | 201801 | 201904 |
| 苹果 | 201905 | 11459.00 | 201906 | 201801 | 201904 |
| 苹果 | 201906 | 11560.00 | 201906 | 201801 | 201904 |
| 香蕉 | 201801 | 10138.00 | 201906 | 201801 | 201904 |
| 香蕉 | 201802 | 10194.00 | 201906 | 201801 | 201904 |
| 香蕉 | 201803 | 10328.00 | 201906 | 201801 | 201904 |
| 香蕉 | 201804 | 10322.00 | 201906 | 201801 | 201904 |
| 香蕉 | 201805 | 10481.00 | 201906 | 201801 | 201904 |
| 香蕉 | 201806 | 10502.00 | 201906 | 201801 | 201904 |
| 香蕉 | 201807 | 10589.00 | 201906 | 201801 | 201904 |
| 香蕉 | 201808 | 10681.00 | 201906 | 201801 | 201904 |
| 香蕉 | 201809 | 10798.00 | 201906 | 201801 | 201904 |
| 香蕉 | 201810 | 10829.00 | 201906 | 201801 | 201904 |
| 香蕉 | 201811 | 10913.00 | 201906 | 201801 | 201904 |
| 香蕉 | 201812 | 11056.00 | 201906 | 201801 | 201904 |
| 香蕉 | 201901 | 11161.00 | 201906 | 201801 | 201904 |
| 香蕉 | 201902 | 11173.00 | 201906 | 201801 | 201904 |
| 香蕉 | 201903 | 11288.00 | 201906 | 201801 | 201904 |
| 香蕉 | 201904 | 11408.00 | 201906 | 201801 | 201904 |
| 香蕉 | 201905 | 11469.00 | 201906 | 201801 | 201904 |
| 香蕉 | 201906 | 11528.00 | 201906 | 201801 | 201904 |

结果显示，"桔子" 最高销售额出现在 2019 年 6 月，最低出现在 2018 年 1 月，第三高销售额出现在 2019 年 4 月。
