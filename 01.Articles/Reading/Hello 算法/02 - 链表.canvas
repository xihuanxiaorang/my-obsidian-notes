{
  "edges": [
    {
      "fromNode": "a6cdd3e1c21c28c0",
      "fromSide": "right",
      "id": "c5efed6efc317862",
      "toNode": "54548cfe4825ebd0",
      "toSide": "left"
    },
    {
      "fromNode": "54548cfe4825ebd0",
      "fromSide": "bottom",
      "id": "f5e74fcbd7b2b3d0",
      "toNode": "ca5f7e67ea7c9591",
      "toSide": "top"
    },
    {
      "fromNode": "ca5f7e67ea7c9591",
      "fromSide": "left",
      "id": "cd6d06d2d93f487b",
      "toNode": "10b22884b0c50324",
      "toSide": "top"
    },
    {
      "fromNode": "c35268b6efad58e2",
      "fromSide": "bottom",
      "id": "655599704462d8e5",
      "toNode": "3f666a58c13c48e3",
      "toSide": "top"
    },
    {
      "fromNode": "10b22884b0c50324",
      "fromSide": "right",
      "id": "9c40b438f6d2b5f3",
      "toNode": "fbedc7163a365f45",
      "toSide": "left"
    },
    {
      "fromNode": "c35268b6efad58e2",
      "fromSide": "top",
      "id": "a783f013028e1a34",
      "toNode": "369363ad74f5dd43",
      "toSide": "bottom"
    },
    {
      "fromNode": "c35268b6efad58e2",
      "fromSide": "right",
      "id": "cc99dc4a4542e924",
      "toNode": "a1c276a2ef4de9b1",
      "toSide": "left"
    },
    {
      "fromNode": "c35268b6efad58e2",
      "fromSide": "right",
      "id": "064d8ebef8304fa3",
      "toNode": "0c011287a1cbb900",
      "toSide": "left"
    },
    {
      "fromNode": "c35268b6efad58e2",
      "fromSide": "right",
      "id": "7125e677104c2579",
      "toNode": "057eef118eca2e57",
      "toSide": "left"
    },
    {
      "fromNode": "c35268b6efad58e2",
      "fromSide": "left",
      "id": "5d721e3c346a0461",
      "styleAttributes": {
      },
      "toNode": "7b7cea0e074e4f5e",
      "toSide": "right"
    }
  ],
  "metadata": {
  },
  "nodes": [
    {
      "color": "4",
      "height": 951,
      "id": "7b7cea0e074e4f5e",
      "label": "应用场景",
      "styleAttributes": {
      },
      "type": "group",
      "width": 720,
      "x": -1520,
      "y": -520
    },
    {
      "color": "1",
      "height": 700,
      "id": "a1c276a2ef4de9b1",
      "label": "主要操作",
      "styleAttributes": {
      },
      "type": "group",
      "width": 690,
      "x": -120,
      "y": -685
    },
    {
      "color": "5",
      "height": 619,
      "id": "057eef118eca2e57",
      "label": "优缺点",
      "styleAttributes": {
      },
      "type": "group",
      "width": 456,
      "x": -120,
      "y": 735
    },
    {
      "color": "5",
      "height": 618,
      "id": "0c011287a1cbb900",
      "label": "特点",
      "styleAttributes": {
      },
      "type": "group",
      "width": 456,
      "x": -120,
      "y": 57
    },
    {
      "color": "2",
      "height": 824,
      "id": "3f666a58c13c48e3",
      "label": "链表类型",
      "styleAttributes": {
      },
      "type": "group",
      "width": 290,
      "x": -620,
      "y": 220
    },
    {
      "height": 295,
      "id": "7dc91bffcbf70597",
      "styleAttributes": {
      },
      "text": "“[[单向链表]]通常用于实现[[栈]]、[[队列]]、[[哈希表]]和[[图]]等数据结构” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=85&annotation=JWQU55H5))\n- 栈与队列:当插入和删除操作都在链表的一端进行时,它表现的特性为先进后出,对应栈;当插入操作在链表的一端进行,删除操作在链表的另一端进行,它表现的特性为先进先出,对应队列。\n- 哈希表:链式地址是解决哈希冲突的主流方案之一,在该方案中,所有冲突的元素都会被放到一个链表中。\n- 图:邻接表是表示图的一种常用方式,其中图的每个顶点都与一个链表相关联,链表中的每个元素都代 表与该顶点相连的其他顶点。",
      "type": "text",
      "width": 680,
      "x": -1500,
      "y": -500
    },
    {
      "height": 289,
      "id": "4bb5be455746b747",
      "styleAttributes": {
      },
      "text": "“[[双向链表]]常用于需要快速查找前一个和后一个元素的场景” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=85&annotation=4EIX8CDT))\n- 高级数据结构:比如在红黑树、B 树中,我们需要访问节点的父节点,这可以通过在节点中保存一个指 向父节点的引用来实现,类似于双向链表。\n- 浏览器历史:在网页浏览器中,当用户点击前进或后退按钮时,浏览器需要知道用户访问过的前一个和 后一个网页。双向链表的特性使得这种操作变得简单。\n- LRU 算法:在缓存淘汰(LRU)算法中,我们需要快速找到最近最少使用的数据,以及支持快速添加 和删除节点。这时候使用双向链表就非常合适。",
      "type": "text",
      "width": 680,
      "x": -1500,
      "y": -180
    },
    {
      "height": 280,
      "id": "b9980b0031424632",
      "styleAttributes": {
      },
      "text": "“[[环形链表]]常用于需要周期性操作的场景,比如操作系统的资源调度。” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=85&annotation=8EC2RWC5))\n- 时间片轮转调度算法:在操作系统中,时间片轮转调度算法是一种常见的 CPU 调度算法,它需要对一 组进程进行循环。每个进程被赋予一个时间片,当时间片用完时,CPU 将切换到下一个进程。这种循 环操作可以通过环形链表来实现。\n- 数据缓冲区:在某些数据缓冲区的实现中,也可能会使用环形链表。比如在音频、视频播放器中,数据 流可能会被分成多个缓冲块并放入一个环形链表,以便实现无缝播放。",
      "type": "text",
      "width": 680,
      "x": -1500,
      "y": 131
    },
    {
      "height": 119,
      "id": "95c798da5f21fe70",
      "styleAttributes": {
      },
      "text": "**非连续存储**：链表的节点在内存中是分散存储的，节点之间通过指针连接。因此，链表不需要预先分配连续的内存空间。",
      "type": "text",
      "width": 416,
      "x": -100,
      "y": 77
    },
    {
      "height": 160,
      "id": "3ceedaaaad404362",
      "styleAttributes": {
      },
      "text": "**节点结构**：每个节点通常由以下两部分组成：\n- **数据域**：存储节点的数据内容。\n- **指针域**：存储指向前驱或后继节点的引用（或地址）。",
      "type": "text",
      "width": 416,
      "x": -100,
      "y": 216
    },
    {
      "height": 100,
      "id": "14481623adeff540",
      "styleAttributes": {
      },
      "text": "**灵活性**：链表特别适合需要频繁插入和删除操作的场景，因为无需像 [[01 - 数组.canvas|数组]] 一样移动其他元素，只需调整指针的指向即可。",
      "type": "text",
      "width": 416,
      "x": -100,
      "y": 395
    },
    {
      "height": 263,
      "id": "eaaa8eb46b29f245",
      "styleAttributes": {
      },
      "text": "“[[双向链表]]:与单向链表相比,双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点(下一个节点)和前驱节点(上一个节点)的引用(指针)。” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=84&annotation=WRCG56SY))",
      "type": "text",
      "width": 250,
      "x": -600,
      "y": 490
    },
    {
      "color": "1",
      "height": 250,
      "id": "369363ad74f5dd43",
      "styleAttributes": {
      },
      "text": "“链表的组成单位是节点(node)对象。每个节点都包含两项数据:节点的“值”和指向下一节点的“引用”” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=80&annotation=IKWNUCT9))\n```java\nclass ListNode {  \n\tint val; // 节点值  \n\tListNode next; // 指向下一节点的引用  \n\tListNode(int x) { val = x; } // 构造函数  \n}\n```",
      "type": "text",
      "width": 560,
      "x": -755,
      "y": -602
    },
    {
      "height": 217,
      "id": "689075707fee396f",
      "styleAttributes": {
      },
      "text": "**优点**：\n- 动态分配内存，节省空间。\n- 插入和删除操作高效，不需要移动元素，时间复杂度为 O(1)。\n- 易于扩展，不受内存连续性的限制，可以灵活的增减节点。",
      "type": "text",
      "width": 416,
      "x": -100,
      "y": 755
    },
    {
      "height": 316,
      "id": "f1367e7ac2529829",
      "styleAttributes": {
      },
      "text": "**缺点**：\n- 访问效率较低，无法随机访问，只能从头开始逐一遍历，查找特定元素的时间复杂度为 O(n)。\n- 额外的内存开销，每个节点需要额外的指针域，增加了存储成本。\n- 实现复杂：相比于数组，链表的插入、删除和遍历操作需要额外的逻辑处理，增加了实现和维护的难度。",
      "type": "text",
      "width": 416,
      "x": -100,
      "y": 1018
    },
    {
      "color": "6",
      "height": 325,
      "id": "c35268b6efad58e2",
      "styleAttributes": {
      },
      "text": "“[[链表]](linked list)是一种线性数据结构,其中的每个元素都是一个节点对象,各个节点通过“引用”相连接。引用记录了下一个节点的内存地址,通过它可以从当前节点访问到下一个节点。” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=79&annotation=32DKUYB8))\n#DataStructure #ToBeOptimized\n\n",
      "type": "text",
      "width": 250,
      "x": -600,
      "y": -205
    },
    {
      "height": 140,
      "id": "10b22884b0c50324",
      "styleAttributes": {
      },
      "text": "“在链表中删除节点也非常方便,只需改变一个节点的引用(指针)即可” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=82&annotation=SQYEZL9S)) \n`pre.next = pre.next.next`",
      "type": "text",
      "width": 300,
      "x": -100,
      "y": -145
    },
    {
      "height": 238,
      "id": "5e394bfe81488f06",
      "styleAttributes": {
      },
      "text": "“[[环形链表]]:如果我们令单向链表的尾节点指向头节点(首尾相接),则得到一个环形链表。在环形链表中,任意节点都可以视作头节点。” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=84&annotation=2VBRJBSB))",
      "type": "text",
      "width": 250,
      "x": -600,
      "y": 779
    },
    {
      "height": 220,
      "id": "55f22afe4a809d76",
      "styleAttributes": {
      },
      "text": "“[[单向链表]]的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点,将最后一个节点称为尾节点,尾节点指向空 None 。” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=84&annotation=9PLW9U69))",
      "type": "text",
      "width": 250,
      "x": -600,
      "y": 240
    },
    {
      "height": 140,
      "id": "a493010129299b40",
      "styleAttributes": {
      },
      "text": "**访问效率较低**：链表的节点是通过指针连接的，因此无法通过索引直接访问某个元素，必须从头节点开始逐个遍历，导致随机访问效率较低。",
      "type": "text",
      "width": 416,
      "x": -100,
      "y": 515
    },
    {
      "height": 156,
      "id": "a6cdd3e1c21c28c0",
      "styleAttributes": {
      },
      "text": "“建立链表分为两步,第一步是初始化各个节点对象,第二步是构建节点之间的引用关系” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=80&annotation=XTQCWB6G))",
      "type": "text",
      "width": 250,
      "x": -75,
      "y": -665
    },
    {
      "height": 60,
      "id": "54548cfe4825ebd0",
      "styleAttributes": {
      },
      "text": "“将头节点当作链表的代称” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=81&annotation=KATGH7HD))",
      "type": "text",
      "width": 250,
      "x": 235,
      "y": -617
    },
    {
      "height": 192,
      "id": "ca5f7e67ea7c9591",
      "styleAttributes": {
      },
      "text": "“想在相邻的两个节点之间插入一个新节点 P , 则只需改变两个节点引用(指针)即可” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=81&annotation=6MINS8FK)) \n```java\np.next = pre.next; \npre.next = p;\n```",
      "type": "text",
      "width": 380,
      "x": 170,
      "y": -445
    },
    {
      "height": 120,
      "id": "fbedc7163a365f45",
      "styleAttributes": {
      },
      "text": "“从头节点出发,逐个向后遍历,直至找到目标节点” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=82&annotation=KWHTSK56))",
      "type": "text",
      "width": 250,
      "x": 300,
      "y": -135
    }
  ]
}