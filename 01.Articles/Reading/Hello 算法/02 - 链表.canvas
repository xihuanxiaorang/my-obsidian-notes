{
	"nodes":[
		{"id":"7b7cea0e074e4f5e","type":"group","x":-1520,"y":-540,"width":720,"height":951,"color":"4","label":"应用场景"},
		{"id":"a1c276a2ef4de9b1","type":"group","x":-120,"y":-640,"width":690,"height":700,"color":"1","label":"主要操作"},
		{"id":"057eef118eca2e57","type":"group","x":-120,"y":780,"width":456,"height":619,"color":"5","label":"优缺点"},
		{"id":"0c011287a1cbb900","type":"group","x":-120,"y":102,"width":456,"height":618,"color":"5","label":"特点"},
		{"id":"3f666a58c13c48e3","type":"group","x":-620,"y":220,"width":290,"height":824,"color":"2","label":"链表类型"},
		{"id":"7dc91bffcbf70597","type":"text","text":"“单向链表通常用于实现[[栈]]、[[队列]]、[[哈希表]]和[[图]]等数据结构” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=85&annotation=JWQU55H5))\n- 栈与队列:当插入和删除操作都在链表的一端进行时,它表现的特性为先进后出,对应栈;当插入操作在链表的一端进行,删除操作在链表的另一端进行,它表现的特性为先进先出,对应队列。\n- 哈希表:链式地址是解决哈希冲突的主流方案之一,在该方案中,所有冲突的元素都会被放到一个链表中。\n- 图:邻接表是表示图的一种常用方式,其中图的每个顶点都与一个链表相关联,链表中的每个元素都代 表与该顶点相连的其他顶点。","x":-1500,"y":-520,"width":680,"height":295},
		{"id":"4bb5be455746b747","type":"text","text":"“双向链表常用于需要快速查找前一个和后一个元素的场景” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=85&annotation=4EIX8CDT))\n- 高级数据结构:比如在红黑树、B 树中,我们需要访问节点的父节点,这可以通过在节点中保存一个指 向父节点的引用来实现,类似于双向链表。\n- 浏览器历史:在网页浏览器中,当用户点击前进或后退按钮时,浏览器需要知道用户访问过的前一个和 后一个网页。双向链表的特性使得这种操作变得简单。\n- LRU 算法:在缓存淘汰(LRU)算法中,我们需要快速找到最近最少使用的数据,以及支持快速添加 和删除节点。这时候使用双向链表就非常合适。","x":-1500,"y":-200,"width":680,"height":289},
		{"id":"c35268b6efad58e2","type":"text","text":"“链表(linked list)是一种线性数据结构,其中的每个元素都是一个节点对象,各个节点通过“引用”相连接。引用记录了下一个节点的内存地址,通过它可以从当前节点访问到下一个节点。” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=79&annotation=32DKUYB8))\n#DataStructure ","x":-600,"y":-214,"width":250,"height":300,"color":"6"},
		{"id":"369363ad74f5dd43","type":"text","text":"“链表的组成单位是节点(node)对象。每个节点都包含两项数据:节点的“值”和指向下一节点的“引用”” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=80&annotation=IKWNUCT9))\n```java\nclass ListNode {  \n\tint val; // 节点值  \n\tListNode next; // 指向下一节点的引用  \n\tListNode(int x) { val = x; } // 构造函数  \n}\n```","x":-755,"y":-602,"width":560,"height":250,"color":"1"},
		{"id":"b9980b0031424632","type":"text","text":"“环形链表常用于需要周期性操作的场景,比如操作系统的资源调度。” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=85&annotation=8EC2RWC5))\n- 时间片轮转调度算法:在操作系统中,时间片轮转调度算法是一种常见的 CPU 调度算法,它需要对一 组进程进行循环。每个进程被赋予一个时间片,当时间片用完时,CPU 将切换到下一个进程。这种循 环操作可以通过环形链表来实现。\n- 数据缓冲区:在某些数据缓冲区的实现中,也可能会使用环形链表。比如在音频、视频播放器中,数据 流可能会被分成多个缓冲块并放入一个环形链表,以便实现无缝播放。","x":-1500,"y":111,"width":680,"height":280},
		{"id":"10b22884b0c50324","type":"text","text":"“在链表中删除节点也非常方便,只需改变一个节点的引用(指针)即可” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=82&annotation=SQYEZL9S)) \n`pre.next = pre.next.next`","x":-100,"y":-100,"width":300,"height":140},
		{"id":"55f22afe4a809d76","type":"text","text":"“[[单向链表]]的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点,将最后一个节点称为尾节点,尾节点指向空 None 。” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=84&annotation=9PLW9U69))","x":-600,"y":240,"width":250,"height":220},
		{"id":"95c798da5f21fe70","type":"text","text":"**非连续存储**：链表的节点在内存中是分散存储的，节点之间通过指针连接。因此，链表不需要预先分配连续的内存空间。","x":-100,"y":122,"width":416,"height":119},
		{"id":"3ceedaaaad404362","type":"text","text":"**节点结构**：每个节点通常由以下两部分组成：\n- **数据域**：存储节点的数据内容。\n- **指针域**：存储指向前驱或后继节点的引用（或地址）。","x":-100,"y":261,"width":416,"height":160},
		{"id":"a6cdd3e1c21c28c0","type":"text","text":"“建立链表分为两步,第一步是初始化各个节点对象,第二步是构建节点之间的引用关系” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=80&annotation=XTQCWB6G))","x":-75,"y":-620,"width":250,"height":156},
		{"id":"14481623adeff540","type":"text","text":"**灵活性**：链表特别适合需要频繁插入和删除操作的场景，因为无需像 [[01 - 数组.canvas|数组]] 一样移动其他元素，只需调整指针的指向即可。","x":-100,"y":440,"width":416,"height":100},
		{"id":"ca5f7e67ea7c9591","type":"text","text":"“想在相邻的两个节点之间插入一个新节点 P , 则只需改变两个节点引用(指针)即可” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=81&annotation=6MINS8FK)) \n```java\np.next = pre.next; \npre.next = p;\n```","x":170,"y":-400,"width":380,"height":192},
		{"id":"54548cfe4825ebd0","type":"text","text":"“将头节点当作链表的代称” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=81&annotation=KATGH7HD))","x":235,"y":-572,"width":250,"height":60},
		{"id":"fbedc7163a365f45","type":"text","text":"“从头节点出发,逐个向后遍历,直至找到目标节点” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=82&annotation=KWHTSK56))","x":300,"y":-90,"width":250,"height":120},
		{"id":"a493010129299b40","type":"text","text":"**访问效率较低**：链表的节点是通过指针连接的，因此无法通过索引直接访问某个元素，必须从头节点开始逐个遍历，导致随机访问效率较低。","x":-100,"y":560,"width":416,"height":140},
		{"id":"689075707fee396f","type":"text","text":"**优点**：\n- 动态分配内存，节省空间。\n- 插入和删除操作高效，不需要移动元素，时间复杂度为 O(1)。\n- 易于扩展，不受内存连续性的限制，可以灵活的增减节点。","x":-100,"y":800,"width":416,"height":217},
		{"id":"f1367e7ac2529829","type":"text","text":"**缺点**：\n- 访问效率较低，无法随机访问，只能从头开始逐一遍历，查找特定元素的时间复杂度为 O(n)。\n- 额外的内存开销，每个节点需要额外的指针域，增加了存储成本。\n- 实现复杂：相比于数组，链表的插入、删除和遍历操作需要额外的逻辑处理，增加了实现和维护的难度。","x":-100,"y":1063,"width":416,"height":316},
		{"id":"eaaa8eb46b29f245","type":"text","text":"“[[双向链表]]:与单向链表相比,双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点(下一个节点)和前驱节点(上一个节点)的引用(指针)。” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=84&annotation=WRCG56SY))","x":-600,"y":490,"width":250,"height":263},
		{"id":"5e394bfe81488f06","type":"text","text":"“[[环形链表]]:如果我们令单向链表的尾节点指向头节点(首尾相接),则得到一个环形链表。在环形链表中,任意节点都可以视作头节点。” ([pdf](zotero://open-pdf/library/items/TELK6EIY?page=84&annotation=2VBRJBSB))","x":-600,"y":779,"width":250,"height":238}
	],
	"edges":[
		{"id":"c5efed6efc317862","fromNode":"a6cdd3e1c21c28c0","fromSide":"right","toNode":"54548cfe4825ebd0","toSide":"left"},
		{"id":"f5e74fcbd7b2b3d0","fromNode":"54548cfe4825ebd0","fromSide":"bottom","toNode":"ca5f7e67ea7c9591","toSide":"top"},
		{"id":"cd6d06d2d93f487b","fromNode":"ca5f7e67ea7c9591","fromSide":"left","toNode":"10b22884b0c50324","toSide":"top"},
		{"id":"655599704462d8e5","fromNode":"c35268b6efad58e2","fromSide":"bottom","toNode":"3f666a58c13c48e3","toSide":"top"},
		{"id":"f7351d51a20ded65","fromNode":"c35268b6efad58e2","fromSide":"left","toNode":"7b7cea0e074e4f5e","toSide":"right"},
		{"id":"9c40b438f6d2b5f3","fromNode":"10b22884b0c50324","fromSide":"right","toNode":"fbedc7163a365f45","toSide":"left"},
		{"id":"a783f013028e1a34","fromNode":"c35268b6efad58e2","fromSide":"top","toNode":"369363ad74f5dd43","toSide":"bottom"},
		{"id":"cc99dc4a4542e924","fromNode":"c35268b6efad58e2","fromSide":"right","toNode":"a1c276a2ef4de9b1","toSide":"left"},
		{"id":"064d8ebef8304fa3","fromNode":"c35268b6efad58e2","fromSide":"right","toNode":"0c011287a1cbb900","toSide":"left"},
		{"id":"7125e677104c2579","fromNode":"c35268b6efad58e2","fromSide":"right","toNode":"057eef118eca2e57","toSide":"left"}
	]
}