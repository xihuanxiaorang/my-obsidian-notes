---
tags:
  - Algorithm
  - Sort
refrence:
  - 漫画算法：小灰的算法之旅
refrence_url:
  - zotero://open-pdf/library/items/XSHZSFBR?page=200
repository: https://github.com/xihuanxiaorang/algorithm-study/blob/main/sorting-algorithm/src/main/java/fun/xiaorang/study/algorithm/sorting/CocktailSort.java
create_time: 2025-01-18 11:19
update_time: 2025/04/10 23:19
priority: 10
---

鸡尾酒排序（Cocktail Sort）是[[冒泡排序|冒泡排序]]的改进版本，基于冒泡排序的双向遍历思想，旨在解决冒泡排序在某些情况下效率低下的问题。

## 背景

冒泡排序通过逐步比较和交换相邻元素，将较大的元素推向序列的末尾，较小的元素推向序列的前端。然而，当序列两端已经接近有序时，冒泡排序仍然会执行不必要的比较，导致效率低下。

举个例子，假设有一个由 8 个数字组成的无序数列 {2, 3, 4, 5, 6, 7, 8, 1}，希望进行升序排序。若使用冒泡排序，排序过程如下：
![[排序算法-冒泡排序|700]]

在这个例子中，除了 1 需要交换外，其他数字已经是有序的。然而，冒泡排序仍然会进行七轮比较和交换，这显然不够高效。

鸡尾酒排序通过**双向冒泡**（从左到右和从右到左交替进行），避免了不必要的遍历，从而提高了排序效率。

## 原理

鸡尾酒排序的基本思想与冒泡排序类似，只是**在每一轮排序中，先从左到右进行比较和交换，再从右到左进行比较和交换**。通过双向遍历，它能够在序列两端已经有序时提前结束排序，减少不必要的操作。

## 算法流程

以升序排列为例，鸡尾酒排序的步骤如下：

1. 从左到右遍历，比较相邻元素并交换顺序错误的元素，最大元素会被推到序列末尾。
2. 从右到左遍历，比较相邻元素并交换顺序错误的元素，最小元素会被推到序列前端。
3. 每次遍历后，忽略已排序部分，继续处理未排序部分。
4. 重复步骤 1~3，直至没有元素发生交换，排序完成。

![[排序算法-鸡尾酒排序|300]]

## 算法特性

- **时间复杂度**：
    - 平均和最坏情况：$O(n^2)$
    - 最好情况：$O(n)$（当序列接近有序时）。
- **空间复杂度**：$O(1)$，为原地排序算法。
- **稳定性**：稳定。

## 代码实现

#CodeSnippet

```java
public class CocktailSort {
  public static void main(String[] args) {
    //    int[] nums = new int[]{3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48};
    int[] nums = new int[]{2, 3, 4, 5, 6, 7, 8, 1};
    System.out.println("排序前：" + Arrays.toString(nums));
    cocktailSort(nums);
    System.out.println("排序后：" + Arrays.toString(nums));
  }

  /**
   * 鸡尾酒排序
   *
   * @param arr 待排序数组
   */
  private static void cocktailSort(int[] arr) {
    // 用于标记无序数列的左边界
    int left = 0;
    // 用于标记无序数列的右边界
    int right = arr.length - 1;
    // 用于标记最后一次交换的位置
    int lastExchangeIndex = 0;
    // 用于标记是否发生了元素交换
    boolean swapped;
    do {
      // 重置标记
      swapped = false;
      // 从左到右遍历，将最大的元素放到右边
      for (int j = left; j < right; j++) {
        if (arr[j] > arr[j + 1]) {
          swap(arr, j, j + 1);
          // 标记发生了交换
          swapped = true;
          // 更新最后一次交换的位置
          lastExchangeIndex = j;
        }
      }
      // 如果没有元素交换，则说明数组已经有序，直接退出循环
      if (!swapped) {
        break;
      }
      // 更新无序数列的右边界
      right = lastExchangeIndex;
      // 重置标记
      swapped = false;
      // 从右到左遍历，将最小的元素放到左边
      for (int j = right; j > left; j--) {
        if (arr[j] < arr[j - 1]) {
          swap(arr, j, j - 1);
          // 标记发生了交换
          swapped = true;
          // 更新最后一次交换的位置
          lastExchangeIndex = j;
        }
      }
      // 更新无序数列的左边界
      left = lastExchangeIndex;
    } while (swapped); // 如果没有发生交换，则说明数组已经有序，直接退出循环
  }
}
```

- **初始化：**
	- `left` 和 `right`：这两个变量分别表示当前排序区间的左右边界。每次排序后，排序区间逐渐缩小，避免不必要的比较。
	- `lastExchangeIndex`：记录上一次交换的位置。在每一轮排序中，这个位置标记了最后一次交换发生的地方。通过更新 `lastExchangeIndex`，可以动态调整排序的区间，避免重新比较已经排好序的部分。
	- `swapped`：布尔变量，表示每轮排序中是否发生了元素交换。如果某一轮没有发生交换，说明数组已经有序，可以提前退出排序。
- **外层 `do-while` 循环：**
	- `do-while` 循环确保至少执行一次排序。当某一轮排序中未发生任何交换时，表示数组已经完全有序，循环结束。
	- 每轮开始时，`swapped` 被重置为 `false`，表示当前轮次默认没有发生交换。
- **从左到右的遍历：**
	- 在 `left` 到 `right` 范围内，从左到右遍历数组，逐步比较并交换相邻元素。如果前一个元素大于后一个元素，则交换它们的位置。
	- 每次交换后，`lastExchangeIndex` 更新为当前交换的位置。这个位置的更新是至关重要的，因为它表示了当前排序中最后一次发生交换的地方。通过记录这个位置，我们可以减少未排序区间的范围，避免对已经排序的部分再次进行比较。
	- 如果在某一轮遍历中没有发生交换，说明当前部分已经是有序的，直接跳出循环，结束排序。
- **从右到左的遍历：**
	- 接下来，从 `right` 到 `left` 范围内，进行反向遍历，同样比较并交换相邻的元素。
	- 如果发生交换，同样更新 `lastExchangeIndex`。
	- 如果这一轮没有发生交换，说明排序已完成，提前退出排序。
- **更新边界：**
    - 每一轮排序完成后，`lastExchangeIndex` 用来更新排序区间的左右边界。
        - `right` 更新为 `lastExchangeIndex`，意味着数组右侧已经排好序，不需要再处理。
        - `left` 更新为 `lastExchangeIndex`，意味着数组左侧已经排好序，也不需要继续处理。
    - 每次更新边界后，未排序的区间会逐渐缩小，避免重复排序已经有序的部分。
