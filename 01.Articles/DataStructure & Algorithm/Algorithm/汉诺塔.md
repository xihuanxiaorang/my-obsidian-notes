---
tags:
  - Algorithm
refrence:
  - Hello 算法
refrence_url:
  - zotero://open-pdf/library/items/TELK6EIY?page=274
  - https://www.bilibili.com/video/BV1gJ41177fX/?vd_source=84272a2d7f72158b38778819be5bc6ad
  - https://www.bilibili.com/video/BV1E4411H73v?p=155&vd_source=84272a2d7f72158b38778819be5bc6ad
repository: https://github.com/xihuanxiaorang/java-study/blob/main/algorithm-study/divide-to-conquer/src/main/java/fun/xiaorang/study/algorithm/dividetoconquer/TowerOfHanoi.java
create_time: 2025-01-23 22:25
update_time: 2025/03/06 17:51
---

汉诺塔（**Tower of Hanoi**）是一种经典的数学益智游戏，由法国数学家**爱德华·卢卡斯（Édouard Lucas）** 于 **1883 年**提出。

## 传说故事

传说在印度贝拿勒斯（Benares，也被认为是宇宙中心），梵天建造了一座由**三根金刚石柱**支撑的神庙，柱子上套着 **64 个黄金圆盘**，圆盘按从大到小依次堆叠，形成完美的塔状结构。这便是传说中的 **"梵塔"**。

梵天命令僧侣们将这些圆盘移动到另一根柱子上，遵循以下**规则**： ^fef606

1. **圆盘只能从一根柱子顶部拿出，从另一根柱子顶部放入**。
2. **每次只能移动一个圆盘**。
3. **小圆盘必须时刻位于大圆盘之上**。

僧侣们日夜不停地搬运圆盘。当所有圆盘按照规则完成移动时，世界将崩塌，化为尘埃。

## 数学问题

汉诺塔的传说充满神秘色彩，但实际上它是一个典型的数学问题，常用来考察**递归**与**分治**思想： #Recursion #DivideToConquer

> [!question]
> 给定三根柱子，记为 `A`、`B` 和 `C` 。起始状态下，柱子 `A` 上套着 $n$ 个圆盘，它们从上到下按照从小到大的顺序排列。我们的任务是要把这 $n$ 个圆盘移到柱子 `C` 上，并保持它们的原有顺序不变（如下图所示）。在移动圆盘的过程中，需要遵守[[#^fef606|规则]]。

![](https://img.xiaorang.fun/202501241908675.png)

我们将规模为 $i$ 的汉诺塔问题记作 $f(i)$。例如 $f(3)$ 代表将 $3$ 个圆盘从 `A` 移动至 `C` 的汉诺塔问题。

### 考虑基本情况

如下图所示，对于问题 $f(1)$，即当只有一个圆盘时，我们将它直接从 `A` 移动至 `C` 即可。

![](https://img.xiaorang.fun/202501241914089.gif)

如下图所示，对于问题 $f(2)$，即当有两个圆盘时，**由于要时刻满足小圆盘在大圆盘之上，因此需要借助 `B` 来完成移动**。

1. 先将上面的小圆盘从 `A` 移至 `B` 。
2. 再将大圆盘从 `A` 移至 `C` 。
3. 最后将小圆盘从 `B` 移至 `C` 。

![](https://img.xiaorang.fun/202501241919881.gif)

解决问题 $f(2)$ 的过程可总结为：**将两个圆盘借助 `B` 从 `A` 移至 `C`** 。其中，`C` 称为**目标柱**、`B` 称为**缓冲柱**。

### 子问题分解

对于问题 $f(3)$，即当有三个圆盘时，情况变得稍微复杂了一些。

因为已知 $f(1)$ 和 $f(2)$ 的解，所以我们可从分治角度思考，**将 `A` 顶部的两个圆盘看作一个整体**，执行下图所示的步骤。这样三个圆盘就被顺利地从 `A` 移至 `C` 了。

1. 令 `B` 为目标柱、`C` 为缓冲柱，将两个圆盘从 `A` 移至 `B` 。
2. 将 `A` 中剩余的一个圆盘从 `A` 直接移动至 `C` 。
3. 令 `C` 为目标柱、`A` 为缓冲柱，将两个圆盘从 `B` 移至 `C` 。

![](https://img.xiaorang.fun/202501242207115.gif)

从本质上看，**我们将问题 $f(3)$ 划分为两个子问题 $f(2)$ 和一个子问题 $f(1)$**。按顺序解决这三个子问题之后，原问题随之得到解决。这说明子问题是独立的，而且解可以合并。

至此，我们可总结出下图所示的解决汉诺塔问题的分治策略：将原问题 $f(n)$ 划分为两个子问题 $f(n−1)$ 和一个子问题 $f(1)$，并按照以下顺序解决这三个子问题。

1. 将 $n−1$ 个圆盘借助 `C` 从 `A` 移至 `B`。
2. 将剩余 $1$ 个圆盘从 `A` 直接移至 `C`。
3. 将 $n−1$ 个圆盘借助 `A` 从 `B` 移至 `C`。

对于这两个子问题 $f(n−1)$，可以**通过相同的方式进行递归划分，直至达到最小子问题 $f(1)$**。而 $f(1)$ 的解是已知的，只需一次移动操作即可。

![](https://img.xiaorang.fun/202501242214958.png)

### 代码实现

在代码中，我们声明一个递归函数 `dfs(i, src, buf, tar)` ，它的作用是将柱 `src` 顶部的 num 个圆盘借助缓冲柱 `buf` 移动至目标柱 `tar`。

```java
public class TowerOfHanoi {
  public static void main(String[] args) {
    // 调用汉诺塔算法，将2个盘子从A柱移动到C柱，使用B柱作为缓冲柱
    dfs(8, 'A', 'B', 'C');
  }

  /**
   * 解决汉诺塔问题的递归方法
   *
   * @param num 盘子的数量
   * @param src 源柱子
   * @param buf 缓冲柱
   * @param tar 目标柱
   */
  private static void dfs(int num, char src, char buf, char tar) {
    // 基本情况：只有一个盘子时，直接从源柱子移动到目标柱子
    if (num == 1) {
      System.out.println("将第 " + num + " 个盘子从 " + src + " 移动到 " + tar);
      return;
    }
    // 递归步骤：
    // 1. 将前 num-1 个盘子从源柱子移动到缓冲柱
    dfs(num - 1, src, tar, buf);
    // 2. 将第 num 个盘子从源柱子移动到目标柱
    System.out.println("将第 " + num + " 个盘子从 " + src + " 移动到 " + tar);
    // 3. 将前 num-1 个盘子从缓冲柱移动到目标柱，
    dfs(num - 1, buf, src, tar);
  }
}
```

### 复杂度分析

如下图所示，汉诺塔问题形成一棵高度为 n 的递归树，每个节点代表一个子问题，对应一个开启的 `dfs()` 函数，**因此时间复杂度为 $O(2^n)$ ，空间复杂度为 $O(n)$** 。
![](https://img.xiaorang.fun/202502042311122.png)

> [!quote]
> - 如果有 $n$ 个圆盘，最少需要 $2^n - 1$ 次移动。
> - 对于传说中的 64 个圆盘：
>   - 移动次数为 **$2^{64} - 1$**，约等于 **$1.8446744 \times 10^{19}$** 次。
>   - 假设僧侣们每秒移动一个圆盘，完成任务大约需要 5850 亿年，远远超过了现在对宇宙年龄的估计。所以，倘若这个传说是真的，我们应该不需要担心世界末日的到来。
