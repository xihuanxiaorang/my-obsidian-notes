---
tags:
  - Java
version: JDK8
refrence_url:
  - https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html
create_time: 2025/07/23 22:39
update_time: 2025/07/28 18:19
---

## 定义

Java 允许**在一个类的内部定义另一个类**，这样的类被称为**内部类**（Inner Class），例如：

```java hl:4,8
class OuterClass {  
  // ...

  class InnerClass {  
    // ...  
  }

  static class StaticInnerClass {
    // ...
  }
}
```

## 为什么使用内部类？

使用内部类的主要原因包括：

- 逻辑分组：当某个类仅在另一个类中使用时，将其作为内部类定义，有助于将相关逻辑集中管理，保持包结构简洁。
- 增强封装性：内部类可以访问外部类的所有成员（包括私有成员），从而在不暴露实现细节的前提下实现更紧密的封装。同时，内部类本身也可对外隐藏，限制其作用范围。
- 提升可读性与可维护性：将仅服务于外部类的小型类定义在其内部，可使代码结构更紧凑、关系更清晰，便于理解和维护。

示例：引擎作为车的一部分而存在。

```java hl:3
public class Car {
  // ...
  public class Engine {
    // ...
  }
}
```

## 分类

### 成员内部类

成员内部类（Member Inner Class）是定义在外部类内部、方法体外部的非静态类，作为外部类的一个成员，它必须依附于外部类的具体实例，不能独立存在。

特性：
- **访问方式**：
	- 成员内部类 → 外部类：可直接访问外部类的所有成员（属性和方法），包括私有的。
	- 外部类 → 成员内部类：需先创建成员内部类实例，再通过该实例进行访问。
	- 外部其他类 → 成员内部类：[[#^a4e722|需先创建外部类实例，在此基础上创建成员内部类实例]]，再通过该实例进行访问。
- **访问修饰符**：可以使用任意访问修饰符（`private`、`protected`、`public` 或 `default`）进行修饰；
- **静态成员限制**：不能声明静态成员（如：静态变量、静态方法、[[代码块#静态代码块|静态代码块]]、成员接口），但常量除外；
	- 因为静态成员属于类本身，独立于任何实例，而成员内部类依赖于外部类的具体实例而存在。
- **作用域**：与外部类的其他成员一样，成员内部类的作用域范围为整个外部类体。
- **变量重名处理**：[[#^1fab9c]]
	- 遵循就近原则，优先访问当前作用域中的变量。
	- 若访问成员内部类自身的同名成员变量，可使用 `this.变量名` 明确指定；
	- 若访问外部类中的同名成员变量，可使用 `OuterClass.this.变量名` 明确指定。

创建成员内部类实例：

```java
// 创建外部类实例  
OuterClass outerInstance = new OuterClass();  
// 基于外部类实例，创建成员内部类实例
OuterClass.InnerClass innerInstance = outerInstance.new InnerClass();				
```

^a4e722

示例 1：[DataStructure.java](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/DataStructure.java)，打印数组中偶数索引位置的元素。

```java hl:34
public class DataStructure {  
  // Create an array  
  private final static int SIZE = 15;  
  private final int[] arrayOfInts = new int[SIZE];  

  public DataStructure() {  
    // fill the array with ascending integer values  
    for (int i = 0; i < SIZE; i++) {  
      arrayOfInts[i] = i;  
    }  
  }  

  public void printEven() {  
    // Print out values of even indices of the array  
    DataStructureIterator iterator = this.new EvenIterator();  
    while (iterator.hasNext()) {  
      System.out.print(iterator.next() + " ");  
    }  
    System.out.println();  
  }  

  public static void main(String[] s) {  
    // Fill the array with integer values and print out only  
    // values of even indices  
    DataStructure ds = new DataStructure();  
    ds.printEven();  
  }  

  // Inner class implements the DataStructureIterator interface,  
  // which extends the Iterator<Integer> interface  
  interface DataStructureIterator extends java.util.Iterator<Integer> {  
  }  

  private class EvenIterator implements DataStructureIterator {  
    // Start stepping through the array from the beginning  
    private int nextIndex = 0;  

    @Override  
    public boolean hasNext() {  
      // Check if the current element is the last in the array  
      return (nextIndex <= SIZE - 1);  
    }  

    @Override  
    public Integer next() {  
      // Record a value of an even index of the array  
      Integer retValue = arrayOfInts[nextIndex];  
      // Get the next even element  
      nextIndex += 2;  
      return retValue;  
    }  
  }  
}
```

- 外部类 `DataStructure`：
	- 构造函数：初始化数组，填充从 0 开始的连续整数；
	- `printEven` 方法：用于打印数组中偶数索引位置的元素，具体逻辑由成员内部类 `EvenIterator` 实现。
- 成员内部类 `EvenIterator`：
	- 实现了 `DataStructureIterator` 接口，该接口继承自 `Iterator<Integer>` 迭代器接口；
	- 封装了遍历数组中偶数索引位置元素的迭代逻辑。

输出结果：

```text
0 2 4 6 8 10 12 14
```

示例 2：成员内部类变量遮蔽

```java hl:5,16,18
public class MemberVariableShadowExample {
  public int x = 0;

  public static void main(String... args) {
    final InnerClass innerInstance = new MemberVariableShadowExample().new InnerClass();
    innerInstance.printValue(23);
  }

  class InnerClass {
    public int x = 1;

    void printValue(int x) {
      // 局部变量
      System.out.println("LocalVariable.x = " + x);
      // 成员内部类的同名成员变量
      System.out.println("MemberInnerClass.x = " + this.x);
      // 外部类的同名成员变量
      System.out.println("OuterClass.x = " + MemberVariableShadowExample.this.x);
    }
  }
}
```

^1fab9c

输出结果：

```text
LocalVariable.x = 23
MemberInnerClass.x = 1
OuterClass.x = 0
```

### 静态内部类

静态内部类（Static Inner Class）是定义在外部类内部、方法体外部的静态类，作为外部类的一个静态成员。

特性：
- **访问方式**：
	- 静态内部类 → 外部类：
		- 静态成员（属性和方法）：可直接访问；
		- 非静态成员：无法直接访问，需借助外部类实例。
	- 外部类 → 静态内部类：
		- 静态成员（属性或方法）：可通过静态内部类类名直接访问；
		- 非静态成员：需先[[#^72b940|创建静态内部类实例]]，再通过该实例进行访问。
	- 外部其他类 → 静态内部类：
		- 静态成员（属性或方法）：可通过静态内部类类名直接访问；
		- 非静态成员：可以直接[[#^72b940|创建静态内部类实例]]，然后再通过该实例进行访问（区别于[[#成员内部类]]，不需要先创建外部类的实例对象）。
- **访问修饰符**：可以使用任意访问修饰符（`private`、`protected`、`public` 或 `default`）进行修饰；
- **作用域**：与外部类的其他成员一样，静态内部类的作用域范围为整个外部类体。
- **变量重名处理**：
	- 遵循就近原则，优先访问当前作用域中的变量。
	- 若访问静态内部类自身的同名静态成员变量，可使用 `StaticInnerClass.变量名` 明确指定；
	- 若访问外部类中的同名静态成员变量，可使用 `OuterClass.变量名` 明确指定。

创建静态内部类实例：

```java
// 实例化静态内部类的标准方式，与顶级类实例化相同
OuterClass.StaticInnerClass instance = new OuterClass.StaticInnerClass();

// 若在 OuterClass 内部使用，可省略类名前缀
StaticInnerClass instance = new StaticInnerClass();
```

^72b940

示例 1：静态内部类 vs 成员内部类 vs 顶级类

```java hl:9,14,26,28,35-36
public class OuterClass {
  static String staticField = "Static outer field";
  String instanceField = "Instance outer field";

  public static void main(String[] args) {
    System.out.println("Member inner class:");
    System.out.println("-------------------");
    OuterClass outer = new OuterClass();
    InnerClass memberInner = outer.new InnerClass();
    memberInner.accessOuter();

    System.out.println("\nStatic inner class:");
    System.out.println("--------------------");
    StaticInnerClass staticInner = new StaticInnerClass();
    staticInner.accessOuter(outer);

    System.out.println("\nTop-level class:");
    System.out.println("----------------");
    TopLevelClass topLevel = new TopLevelClass();
    topLevel.accessOuter(outer);
  }

  static class StaticInnerClass {
    void accessOuter(OuterClass outer) {
      // 不能直接访问外部类非静态成员，需要通过实例
      System.out.println(outer.instanceField);
      // 可直接访问外部类的静态成员
      System.out.println(staticField);
    }
  }

  class InnerClass {
    void accessOuter() {
      // 可直接访问外部类所有成员
      System.out.println(instanceField);
      System.out.println(staticField);
    }
  }
}
```

```java hl:6-7
// 顶级类（非嵌套类）
public class TopLevelClass {  
  void accessOuter(OuterClass outer) {  
    // 不能直接访问外部类的非静态成员  
    // System.out.println(OuterClass.instanceField); // 编译错误  
    System.out.println(outer.instanceField);  
    System.out.println(OuterClass.staticField);  
  }}
```

输出结果：

```text
Member inner class:
-------------------
Instance outer field
Static outer field

Static inner class:
--------------------
Instance outer field
Static outer field

Top-level class:
----------------
Instance outer field
Static outer field
```

示例 2：静态内部类中的变量遮蔽

```java hl:5,16,18
public class StaticVariableShadowExample {
  static int x = 0;

  public static void main(String[] args) {
    final StaticInnerClass staticInnerInstance = new StaticInnerClass();
    staticInnerInstance.printValues(23);
  }

  static class StaticInnerClass {
    static int x = 1;

    void printValues(int x) {
      // 局部变量
      System.out.println("LocalVariable.x = " + x);
      // 静态内部类的同名静态成员变量
      System.out.println("StaticInnerClass.x = " + StaticInnerClass.x);
      // 外部类的同名静态成员变量
      System.out.println("OuterClass.x = " + StaticVariableShadowExample.x);
    }
  }
}
```

输出结果：

```text
LocalVariable.x = 23
StaticInnerClass.x = 1
OuterClass.x = 0
```

### 局部内部类

局部内部类（Local Inner Class）是定义在方法体（或构造器、代码块）内部的类，通常用于封装只在该方法中使用的逻辑。

特性：
- **访问方式**：
	- 局部内部类 → 外部类：
		- 可直接访问外部类的所有成员（属性和方法），包括私有的。
		- 若定义在静态方法中，则只能访问外部类的静态成员。
	- 局部内部类 → 所在方法的局部变量和参数：
		- 只能访问 `final` 或实际上是 `final`（effectively final）的变量和参数；
		- "实际上是 `final` 的"是指：变量一旦赋值后未被修改。
	- 外部类 → 局部内部类：需先在其作用域范围（即方法体）之内创建局部内部类实例，再通过该实例进行访问。
	- 外部其他类 → 成员内部类：无法访问（受限于作用域）。
- **访问修饰符**：不能使用任何访问修饰符进行修饰。
- **静态成员限制**：不能声明静态成员（如：静态变量、静态方法、[[代码块#静态代码块|静态代码块]]、成员接口），但常量除外；
- **作用域**：仅限于定义它的方法（构造器、代码块）中。
- **变量重名处理**：
	- 遵循就近原则，优先访问当前作用域中的变量。
	- 若访问局部内部类自身的同名成员变量，可使用 `this.变量名` 明确指定；
	- 若访问外部类中的同名成员变量，可使用 `OuterClass.this.变量名` 明确指定。

示例 1：LocalClassExample](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/LocalClassExample.java)，验证电话号码的有效性。

```java hl:7,26-27
public class LocalClassExample {
  static String regularExpression = "[^0-9]";

  public static void validatePhoneNumber(String phoneNumber1, String phoneNumber2) {
    final int numberLength = 10;

    class PhoneNumber {
      String formattedPhoneNumber = null;

      PhoneNumber(String phoneNumber) {
        // 移除非数字字符
        String currentNumber = phoneNumber.replaceAll(regularExpression, "");
        // 判断是否为合法长度
        if (currentNumber.length() == numberLength) {
          formattedPhoneNumber = currentNumber;
        } else {
          formattedPhoneNumber = null;
        }
      }

      public String getNumber() {
        return formattedPhoneNumber;
      }
    }

    PhoneNumber myNumber1 = new PhoneNumber(phoneNumber1);
    PhoneNumber myNumber2 = new PhoneNumber(phoneNumber2);

    if (myNumber1.getNumber() == null) {
      System.out.println("First number is invalid");
    } else {
      System.out.println("First number is " + myNumber1.getNumber());
    }
    if (myNumber2.getNumber() == null) {
      System.out.println("Second number is invalid");
    } else {
      System.out.println("Second number is " + myNumber2.getNumber());
    }
  }

  public static void main(String... args) {
    validatePhoneNumber("123-456-7890", "456-7890");
  }
}
```

输出结果：

```text
First number is 1234567890  
Second number is invalid
```

示例 2：局部内部类中的变量遮蔽

```java hl:6,13,15,20
public class LocalVariableShadowExample {
  public int x = 0;

  public void printValue(int x) {
    // 局部变量
    System.out.println("LocalVariable.x = " + x);

    class LocalInnerClass {
      final int x = 1;

      public void printValue() {
        // 成员内部类的同名成员变量
        System.out.println("LocalInnerClass.x = " + this.x);
        // 外部类的同名成员变量
        System.out.println("OuterClass.x = " + LocalVariableShadowExample.this.x);
      }
    }

    // 创建局部类实例
    final LocalInnerClass localInnerClass = new LocalInnerClass();
    localInnerClass.printValue();
  }

  public static void main(String[] args) {
    new LocalVariableShadowExample().printValue(23);
  }
}
```

输出结果：

```text
LocalVariable.x = 23
LocalInnerClass.x = 1
OuterClass.x = 0
```

### 匿名内部类

匿名内部类（Anonymous Inner Class）其实是没有名字的[[#局部内部类]]，常用于临时实现接口或继承类，在创建对象的同时定义类的具体行为。

特性：
- **语法**：
	- 匿名内部类基于接口或类进行"实现"或"继承"。
	- 使用 `new 接口名/基类名() { … }` 的语法定义一个新的实现类或子类，并立即创建该类的实例。
	- 类体位于花括号 `{}` 中，是类的唯一且最终的定义。
- **访问方式**：
	- 匿名内部类 → 外部类：
		- 可直接访问外部类的所有成员（属性和方法)，包括私有的。
		- 若定义在静态方法中，则只能访问外部类的静态成员。
	- 匿名内部类 → 所在方法的局部变量和参数：
		- 只能访问 `final` 或实际上是 `final`（effectively final）的变量和参数；
		- "实际上是 `final` 的"是指：变量一旦赋值后未被修改。
	- 外部类 → 匿名内部类：使用创建好的实例进行访问。
	- 外部其他类 → 匿名内部类：无法访问（受限于作用域）。
- **访问修饰符**：不能使用任何访问修饰符进行修饰。
- **成员限制**：
	- 可以声明：成员变量，实例方法（包括不在父接口或基类中声明的方法），[[代码块#实例代码块]]，局部类；
	- 不能声明：构造方法，静态成员（如：静态变量、静态方法、[[代码块#静态代码块]]、成员接口），但常量除外。
- **作用域**：仅限于定义它的方法（构造器、代码块）中。
- **变量重名处理**：
	- 遵循就近原则，优先访问当前作用域中的变量。
	- 若访问匿名内部类自身的同名成员变量，可使用 `this.变量名` 明确指定；
	- 若访问外部类中的同名成员变量，可使用 `OuterClass.this.变量名` 明确指定。

示例 1：匿名内部类实现多语言问候。

```java hl:6,24,40
public class HelloWorldAnonymousClassExample {

  public void sayHello() {

    // 英语问候 - 局部内部类实现
    class EnglishGreeting implements HelloWorld {
      String name = "world";

      @Override
      public void greet() {
        greetSomeone(name);
      }

      @Override
      public void greetSomeone(String someone) {
        name = someone;
        System.out.println("Hello, " + name);
      }
    }

    HelloWorld englishGreeting = new EnglishGreeting();

    // 法语问候 - 匿名内部类实现
    HelloWorld frenchGreeting = new HelloWorld() {
      String name = "tout le monde";

      @Override
      public void greet() {
        greetSomeone(name);
      }

      @Override
      public void greetSomeone(String someone) {
        name = someone;
        System.out.println("Salut, " + name);
      }
    };

    // 西班牙语问候 - 匿名内部类实现
    HelloWorld spanishGreeting = new HelloWorld() {
      String name = "mundo";

      @Override
      public void greet() {
        greetSomeone("mundo");
      }

      @Override
      public void greetSomeone(String someone) {
        name = someone;
        System.out.println("Hola, " + name);
      }
    };

    englishGreeting.greet();
    frenchGreeting.greetSomeone("Fred");
    spanishGreeting.greet();
  }

  public static void main(String... args) {
    new HelloWorldAnonymousClassExample().sayHello();
  }

  interface HelloWorld {
    void greet();

    void greetSomeone(String someone);
  }
}
```

输出结果：

```text
Hello, world
Salut, Fred
Hola, mundo
```

示例 2：匿名内部类中的变量遮蔽

```java hl:6,8,14,16
public class AnonymousVariableShadowExample {
  public int x = 0;

  public void printValue(int x) {
    // 局部变量
    System.out.println("LocalVariable.x = " + x);

    final Runnable runnable = new Runnable() {
      final int x = 1;

      @Override
      public void run() {
        // 匿名内部类的同名成员变量
        System.out.println("AnonymousClass.x = " + this.x);
        // 外部类的同名成员变量
        System.out.println("OuterClass.x = " + AnonymousVariableShadowExample.this.x);
      }
    };

    runnable.run();
  }

  public static void main(String[] args) {
    new AnonymousVariableShadowExample().printValue(23);
  }
}
```

输出结果：

```text
LocalVariable.x = 23
AnonymousClass.x = 1
OuterClass.x = 0
```

## 问题与练习

### 问题

1. 🤔程序 [Problem.java](https://docs.oracle.com/javase/tutorial/java/javaOO/QandE/Problem.java) 无法编译。你需要做什么才能让它编译？为什么？
   🤓删除 `Inner` 类声明前面的 `static` 修饰符，因为静态内部类不能直接访问外部类的实例字段。请参见修正后的版本 [ProblemSolved.java](https://docs.oracle.com/javase/tutorial/java/javaOO/QandE/ProblemSolved.java)。
2. 使用 `javax.swing` 包中的 `Box` 类的 Java API 文档，回答以下问题：
    1. Box 类定义了哪个静态嵌套类？`Box.Filler`。
    2. Box 类中定义了哪个内部类？`Box.AccessibleBox`。
    3. Box 类中内部类的超类是什么？`Container.AccessibleAWTContainer`。
    4. Box 类中的哪些嵌套类可以在任何类中使用？`Box.Filler`。
    5. 如何创建 `Box` 类的 `Filler` 类的实例？`new Box.Filler(minDimension, prefDimension, maxDimension);`

### 练习

栗子 1：获取 [Class1.java](https://docs.oracle.com/javase/tutorial/java/javaOO/QandE/Class1.java) 文件，然后编译并运行 `Class1`。输出是什么？

```text
InnerClass1: getString invoked.  
InnerClass1: getAnotherString invoked.
```

栗子 2：本练习基于  [DataStructure.java](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/DataStructure.java)  类（见[[#成员内部类]]）进行扩展与改写，涉及成员内部类、匿名内部类、Lambda 表达式、方法引用等核心概念。

要求：
1. 定义一个 `print(DataStructureIterator iterator)` 方法，用于接收任意实现了 `DataStructureIterator` 接口的对象并打印元素。使用 `EvenIterator` 类的实例调用该方法，以实现与 `printEven()` 方法相同的功能。

   ⚠️ 注意：以下代码在 `main()` 方法中无法编译：

	```java
	DataStructure ds = new DataStructure();
	ds.print(new EvenIterator()); // ❌ 编译错误
	```

	报错原因：`EvenIterator` 是成员内部类，只能通过 `DataStructure` 的实例在其内部创建。你需要在 `DataStructure` 中定义一个方法，例如 `getEvenIterator()`，用于返回 `EvenIterator` 的实例：

	```java
	public EvenIterator getEvenIterator() {
	  return new EvenIterator();
	}
	```

2. 使用匿名内部类作为参数，调用 `print(DataStructureIterator iterator)` 方法，实现打印奇数索引位置的元素。
   ⚠️ 提示：由于 `SIZE` 和 `arrayOfInts` 是私有的，不能在类外直接访问。可通过定义公有方法（如 `getSize()` 和 `get(int index)`）来间接访问它们。
3. 定义一个重载的 `print(Function<Integer, Boolean> condition)` 方法，使用 Lambda 表达式控制打印逻辑：
   - 使用 Lambda 表达式打印偶数索引位置的元素；
   - 再次使用 Lambda 表达式打印奇数索引位置的元素。

	 ✍️ 提示：遍历索引，调用 `function.apply(index)` 判断是否满足条件：

	```java
	ds.print(i -> i % 2 == 0); // 偶数索引
	ds.print(i -> i % 2 != 0); // 奇数索引
	```

4. 通过方法引用进一步简化 Lambda 表达式：
   - 定义两个静态方法 `isEvenIndex(int index)` 和 `isOddIndex(int index)`，返回是否为偶数/奇数索引；
   - 使用方法引用调用：

		```java
		ds.print(DataStructure::isEvenIndex);
		ds.print(DataStructure::isOddIndex);
		```

	✅ 要求：`isEvenIndex` 和 `isOddIndex` 方法必须匹配 `Function<Integer, Boolean>` 的签名。

```java file:"点我查看答案" fold
public class DataStructure {

  // Create an array
  private final static int SIZE = 15;
  private final int[] arrayOfInts = new int[SIZE];

  public DataStructure() {
    // fill the array with ascending integer values
    for (int i = 0; i < SIZE; i++) {
      arrayOfInts[i] = i;
    }
  }

  public int getSize() {
    return SIZE;
  }

  public int get(int index) {
    return arrayOfInts[index];
  }

  public EvenIterator getEvenIterator() {
    return new EvenIterator();
  }

  public void print(java.util.function.Function<Integer, Boolean> iterator) {
    for (int i = 0; i < SIZE; i++) {
      if (iterator.apply(i)) {
        System.out.print(arrayOfInts[i] + " ");
      }
    }
    System.out.println();
  }

  public void print(DataStructureIterator iterator) {
    while (iterator.hasNext()) {
      System.out.print(iterator.next() + " ");
    }
    System.out.println();
  }

  public void printEven() {
    // Print out values of even indices of the array
    DataStructureIterator iterator = this.new EvenIterator();
    while (iterator.hasNext()) {
      System.out.print(iterator.next() + " ");
    }
    System.out.println();
  }

  public static Boolean isEvenIndex(int index) {
    return index % 2 == 0;
  }

  public static Boolean isOddIndex(int index) {
    return index % 2 != 0;
  }

  public static void main(String[] s) {

    // Fill the array with integer values and print out only
    // values of even indices
    DataStructure ds = new DataStructure();
    System.out.println("printEven()");
    ds.printEven();

    System.out.println("print(DataStructureIterator) with getEvenIterator");
    ds.print(ds.getEvenIterator());

    System.out.println("print(DataStructureIterator) with anonymous class, odd indicies");
    ds.print(new DataStructureIterator() {
      private int nextIndex = 1;

      @Override
      public boolean hasNext() {
        return nextIndex <= ds.getSize() - 1;
      }

      @Override
      public Integer next() {
        final int retValue = ds.get(nextIndex);
        nextIndex += 2;
        return retValue;
      }
    });

    System.out.println("print(Function) with lambda expressions");
    ds.print((i) -> i % 2 == 0);
    ds.print(i -> i % 2 != 0);

    System.out.println("print(Function) with method references");
    ds.print(DataStructure::isEvenIndex);
    ds.print(DataStructure::isOddIndex);
  }

  // Inner class implements the DataStructureIterator interface,
  // which extends the Iterator<Integer> interface

  interface DataStructureIterator extends java.util.Iterator<Integer> {
  }

  private class EvenIterator implements DataStructureIterator {

    // Start stepping through the array from the beginning
    private int nextIndex = 0;

    @Override
    public boolean hasNext() {

      // Check if the current element is the last in the array
      return (nextIndex <= SIZE - 1);
    }

    @Override
    public Integer next() {

      // Record a value of an even index of the array
      Integer retValue = arrayOfInts[nextIndex];

      // Get the next even element
      nextIndex += 2;
      return retValue;
    }
  }
}
```
