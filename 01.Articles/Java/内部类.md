---
tags:
  - Java
version: JDK8
refrence_url:
  - https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html
create_time: 2025/07/23 22:39
update_time: 2025/07/27 23:22
---

## 定义

Java 允许**在一个类的内部定义另一个类**，这样的类被称为**内部类**（Inner Class），例如：

```java hl:4,8
class OuterClass {  
  // ...

  class InnerClass {  
    // ...  
  }

  static class StaticInnerClass {
    // ...
  }
}
```

## 为什么使用内部类？

使用内部类的主要原因包括：

- 逻辑分组：当某个类仅在另一个类中使用时，将其作为内部类定义，有助于将相关逻辑集中管理，保持包结构简洁。
- 增强封装性：内部类可以访问外部类的所有成员（包括私有成员），从而在不暴露实现细节的前提下实现更紧密的封装。同时，内部类本身也可对外隐藏，限制其作用范围。
- 提升可读性与可维护性：将仅服务于外部类的小型类定义在其内部，可使代码结构更紧凑、关系更清晰，便于理解和维护。

示例：引擎作为车的一部分而存在。

```java hl:3
public class Car {
  // ...
  public class Engine {
    // ...
  }
}
```

## 分类

### 成员内部类

成员内部类（Member Inner Class）是定义在外部类内部、方法体外部的非静态类，作为外部类的一个成员，它必须依附于外部类的具体实例，不能独立存在。

特性：
- **访问方式**：
	- 成员内部类 → 外部类：可直接访问外部类的所有成员（属性和方法），包括私有的。
	- 外部类 → 成员内部类：需先创建成员内部类实例，再通过该实例进行访问。
	- 外部其他类 → 成员内部类：[[#^a4e722|需先创建外部类实例，在此基础上创建成员内部类实例]]，再通过该实例进行访问。
- **访问修饰符**：可以使用任意访问修饰符（`private`、`protected`、`public` 或 `default`）进行修饰；
- **静态成员限制**：不能声明静态成员（如：静态变量、静态方法、[[代码块#静态代码块|静态代码块]]、成员接口），但常量除外；
	- 因为静态成员属于类本身，独立于任何实例，而成员内部类依赖于外部类的具体实例而存在。
- **作用域**：与外部类的其他成员一样，成员内部类的作用域范围为整个外部类体。
- **变量重名处理**：[[#^1fab9c]]
	- 遵循就近原则，优先访问当前作用域中的变量。
	- 若访问成员内部类自身的同名成员变量，可使用 `this.变量名` 明确指定；
	- 若访问外部类中的同名成员变量，可使用 `OuterClass.this.变量名` 明确指定。

创建成员内部类实例：

```java
// 创建外部类实例  
OuterClass outerInstance = new OuterClass();  
// 基于外部类实例，创建成员内部类实例
OuterClass.InnerClass innerInstance = outerInstance.new InnerClass();				
```

^a4e722

示例 1：[DataStructure.java](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/DataStructure.java)，打印数组中偶数索引位置的元素。

```java hl:34
public class DataStructure {  
  // Create an array  
  private final static int SIZE = 15;  
  private final int[] arrayOfInts = new int[SIZE];  

  public DataStructure() {  
    // fill the array with ascending integer values  
    for (int i = 0; i < SIZE; i++) {  
      arrayOfInts[i] = i;  
    }  
  }  

  public void printEven() {  
    // Print out values of even indices of the array  
    DataStructureIterator iterator = this.new EvenIterator();  
    while (iterator.hasNext()) {  
      System.out.print(iterator.next() + " ");  
    }  
    System.out.println();  
  }  

  public static void main(String[] s) {  
    // Fill the array with integer values and print out only  
    // values of even indices  
    DataStructure ds = new DataStructure();  
    ds.printEven();  
  }  

  // Inner class implements the DataStructureIterator interface,  
  // which extends the Iterator<Integer> interface  
  interface DataStructureIterator extends java.util.Iterator<Integer> {  
  }  

  private class EvenIterator implements DataStructureIterator {  
    // Start stepping through the array from the beginning  
    private int nextIndex = 0;  

    @Override  
    public boolean hasNext() {  
      // Check if the current element is the last in the array  
      return (nextIndex <= SIZE - 1);  
    }  

    @Override  
    public Integer next() {  
      // Record a value of an even index of the array  
      Integer retValue = arrayOfInts[nextIndex];  
      // Get the next even element  
      nextIndex += 2;  
      return retValue;  
    }  
  }  
}
```

- 外部类 `DataStructure`：
	- 构造函数：初始化数组，填充从 0 开始的连续整数；
	- `printEven` 方法：用于打印数组中偶数索引位置的元素，具体逻辑由成员内部类 `EvenIterator` 实现。
- 成员内部类 `EvenIterator`：
	- 实现了 `DataStructureIterator` 接口，该接口继承自 `Iterator<Integer>` 迭代器接口；
	- 封装了遍历数组中偶数索引位置元素的迭代逻辑。

输出结果：

```text
0 2 4 6 8 10 12 14
```

示例 2：成员内部类变量遮蔽

```java hl:5,16,18
public class MemberVariableShadowExample {
  public int x = 0;

  public static void main(String... args) {
    final InnerClass innerInstance = new MemberVariableShadowExample().new InnerClass();
    innerInstance.printValue(23);
  }

  class InnerClass {
    public int x = 1;

    void printValue(int x) {
      // 局部变量
      System.out.println("LocalVariable.x = " + x);
      // 成员内部类的同名成员变量
      System.out.println("MemberInnerClass.x = " + this.x);
      // 外部类的同名成员变量
      System.out.println("OuterClass.x = " + MemberVariableShadowExample.this.x);
    }
  }
}
```

^1fab9c

输出结果：

```text
LocalVariable.x = 23
MemberInnerClass.x = 1
OuterClass.x = 0
```

### 静态内部类

静态内部类（Static Inner Class）是定义在外部类内部、方法体外部的静态类，作为外部类的一个静态成员。

特性：
- **访问方式**：
	- 静态内部类 → 外部类：
		- 静态成员（属性和方法）：可直接访问；
		- 非静态成员：无法直接访问，需借助外部类实例。
	- 外部类 → 静态内部类：
		- 静态成员（属性或方法）：可通过静态内部类类名直接访问；
		- 非静态成员：需先[[#^72b940|创建静态内部类实例]]，再通过该实例进行访问。
	- 外部其他类 → 静态内部类：
		- 静态成员（属性或方法）：可通过静态内部类类名直接访问；
		- 非静态成员：可以直接[[#^72b940|创建静态内部类实例]]，然后再通过该实例进行访问（区别于[[#成员内部类]]，不需要先创建外部类的实例对象）。
- **访问修饰符**：可以使用任意访问修饰符（`private`、`protected`、`public` 或 `default`）进行修饰；
- **作用域**：与外部类的其他成员一样，静态内部类的作用域范围为整个外部类体。
- **变量重名处理**：
	- 遵循就近原则，优先访问当前作用域中的变量。
	- 若访问静态内部类自身的同名静态成员变量，可使用 `StaticInnerClass.变量名` 明确指定；
	- 若访问外部类中的同名静态成员变量，可使用 `OuterClass.变量名` 明确指定。

创建静态内部类实例：

```java
// 实例化静态内部类的标准方式，与顶级类实例化相同
OuterClass.StaticInnerClass instance = new OuterClass.StaticInnerClass();

// 若在 OuterClass 内部使用，可省略类名前缀
StaticInnerClass instance = new StaticInnerClass();
```

^72b940

示例 1：静态内部类 vs 成员内部类 vs 顶级类

```java hl:9,14,26,28,35-36
public class OuterClass {
  static String staticField = "Static outer field";
  String instanceField = "Instance outer field";

  public static void main(String[] args) {
    System.out.println("Member inner class:");
    System.out.println("-------------------");
    OuterClass outer = new OuterClass();
    InnerClass memberInner = outer.new InnerClass();
    memberInner.accessOuter();

    System.out.println("\nStatic inner class:");
    System.out.println("--------------------");
    StaticInnerClass staticInner = new StaticInnerClass();
    staticInner.accessOuter(outer);

    System.out.println("\nTop-level class:");
    System.out.println("----------------");
    TopLevelClass topLevel = new TopLevelClass();
    topLevel.accessOuter(outer);
  }

  static class StaticInnerClass {
    void accessOuter(OuterClass outer) {
      // 不能直接访问外部类非静态成员，需要通过实例
      System.out.println(outer.instanceField);
      // 可直接访问外部类的静态成员
      System.out.println(staticField);
    }
  }

  class InnerClass {
    void accessOuter() {
      // 可直接访问外部类所有成员
      System.out.println(instanceField);
      System.out.println(staticField);
    }
  }
}
```

```java hl:6-7
// 顶级类（非嵌套类）
public class TopLevelClass {  
  void accessOuter(OuterClass outer) {  
    // 不能直接访问外部类的非静态成员  
    // System.out.println(OuterClass.instanceField); // 编译错误  
    System.out.println(outer.instanceField);  
    System.out.println(OuterClass.staticField);  
  }}
```

输出结果：

```text
Member inner class:
-------------------
Instance outer field
Static outer field

Static inner class:
--------------------
Instance outer field
Static outer field

Top-level class:
----------------
Instance outer field
Static outer field
```

示例 2：静态内部类中的变量遮蔽

```java hl:5,16,18
public class StaticVariableShadowExample {
  static int x = 0;

  public static void main(String[] args) {
    final StaticInnerClass staticInnerInstance = new StaticInnerClass();
    staticInnerInstance.printValues(23);
  }

  static class StaticInnerClass {
    static int x = 1;

    void printValues(int x) {
      // 局部变量
      System.out.println("LocalVariable.x = " + x);
      // 静态内部类的同名静态成员变量
      System.out.println("StaticInnerClass.x = " + StaticInnerClass.x);
      // 外部类的同名静态成员变量
      System.out.println("OuterClass.x = " + StaticVariableShadowExample.x);
    }
  }
}
```

输出结果：

```text
LocalVariable.x = 23
StaticInnerClass.x = 1
OuterClass.x = 0
```

### 局部内部类

局部内部类（Local Inner Class）是定义在方法体（或构造器、代码块）内部的类，通常用于封装只在该方法中使用的逻辑。

特性：
- **访问方式**：
	- 局部内部类 → 外部类：
		- 可直接访问外部类的所有成员（属性和方法），包括私有的。
		- 若定义在静态方法中，则只能访问外部类的静态成员。
	- 局部内部类 → 所在方法的局部变量和参数：
		- 只能访问 `final` 或实际上是 `final`（effectively final）的变量和参数；
		- "实际上是 `final` 的"是指：变量一旦赋值后未被修改。
	- 外部类 → 局部内部类：需先在其作用域范围（即方法体）之内创建局部内部类实例，再通过该实例进行访问。
	- 外部其他类 → 成员内部类：无法访问（受限于作用域）。
- **访问修饰符**：不能使用任何访问修饰符进行修饰。
- **静态成员限制**：不能声明静态成员（如：静态变量、静态方法、[[代码块#静态代码块|静态代码块]]、成员接口），但常量除外；
- **作用域**：仅限于定义它的方法（构造器、代码块）中。
- **变量重名处理**：
	- 遵循就近原则，优先访问当前作用域中的变量。
	- 若访问局部内部类自身的同名成员变量，可使用 `this.变量名` 明确指定；
	- 若访问外部类中的同名成员变量，可使用 `OuterClass.this.变量名` 明确指定。

示例 1：LocalClassExample](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/LocalClassExample.java)，验证电话号码的有效性。

```java hl:7,26-27
public class LocalClassExample {
  static String regularExpression = "[^0-9]";

  public static void validatePhoneNumber(String phoneNumber1, String phoneNumber2) {
    final int numberLength = 10;

    class PhoneNumber {
      String formattedPhoneNumber = null;

      PhoneNumber(String phoneNumber) {
        // 移除非数字字符
        String currentNumber = phoneNumber.replaceAll(regularExpression, "");
        // 判断是否为合法长度
        if (currentNumber.length() == numberLength) {
          formattedPhoneNumber = currentNumber;
        } else {
          formattedPhoneNumber = null;
        }
      }

      public String getNumber() {
        return formattedPhoneNumber;
      }
    }

    PhoneNumber myNumber1 = new PhoneNumber(phoneNumber1);
    PhoneNumber myNumber2 = new PhoneNumber(phoneNumber2);

    if (myNumber1.getNumber() == null) {
      System.out.println("First number is invalid");
    } else {
      System.out.println("First number is " + myNumber1.getNumber());
    }
    if (myNumber2.getNumber() == null) {
      System.out.println("Second number is invalid");
    } else {
      System.out.println("Second number is " + myNumber2.getNumber());
    }
  }

  public static void main(String... args) {
    validatePhoneNumber("123-456-7890", "456-7890");
  }
}
```

输出结果：

```text
First number is 1234567890  
Second number is invalid
```

示例 2：局部内部类中的变量遮蔽

```java hl:6,13,15,20
public class LocalVariableShadowExample {
  public int x = 0;

  public void printValue(int x) {
    // 局部变量
    System.out.println("LocalVariable.x = " + x);

    class LocalInnerClass {
      final int x = 1;

      public void printValue() {
        // 成员内部类的同名成员变量
        System.out.println("LocalInnerClass.x = " + this.x);
        // 外部类的同名成员变量
        System.out.println("OuterClass.x = " + LocalVariableShadowExample.this.x);
      }
    }

    // 创建局部类实例
    final LocalInnerClass localInnerClass = new LocalInnerClass();
    localInnerClass.printValue();
  }

  public static void main(String[] args) {
    new LocalVariableShadowExample().printValue(23);
  }
}
```

输出结果：

```text
LocalVariable.x = 23
LocalInnerClass.x = 1
OuterClass.x = 0
```

### 匿名内部类

匿名内部类（Anonymous Inner Class）其实是没有名字的[[#局部内部类]]，常用于临时实现接口或继承类，在创建对象的同时定义类的具体行为。

特性：
- **语法**：
	- 匿名内部类基于接口或类进行"实现"或"继承"。
	- 使用 `new 接口名/基类名() { … }` 的语法定义一个新的实现类或子类，并立即创建该类的实例。
	- 类体位于花括号 `{}` 中，是类的唯一且最终的定义。
- **访问方式**：
	- 匿名内部类 → 外部类：
		- 可直接访问外部类的所有成员（属性和方法)，包括私有的。
		- 若定义在静态方法中，则只能访问外部类的静态成员。
	- 匿名内部类 → 所在方法的局部变量和参数：
		- 只能访问 `final` 或实际上是 `final`（effectively final）的变量和参数；
		- "实际上是 `final` 的"是指：变量一旦赋值后未被修改。
	- 外部类 → 匿名内部类：使用创建好的实例进行访问。
	- 外部其他类 → 匿名内部类：无法访问（受限于作用域）。
- **访问修饰符**：不能使用任何访问修饰符进行修饰。
- **成员限制**：
	- 可以声明：成员变量，实例方法（包括不在父接口或基类中声明的方法），[[代码块#实例代码块]]，局部类；
	- 不能声明：构造方法，静态成员（如：静态变量、静态方法、[[代码块#静态代码块]]、成员接口），但常量除外。
- **作用域**：仅限于定义它的方法（构造器、代码块）中。
- **变量重名处理**：
	- 遵循就近原则，优先访问当前作用域中的变量。
	- 若访问匿名内部类自身的同名成员变量，可使用 `this.变量名` 明确指定；
	- 若访问外部类中的同名成员变量，可使用 `OuterClass.this.变量名` 明确指定。

示例 1：匿名内部类实现多语言问候。

```java hl:6,24,40
public class HelloWorldAnonymousClassExample {

  public void sayHello() {

    // 英语问候 - 局部内部类实现
    class EnglishGreeting implements HelloWorld {
      String name = "world";

      @Override
      public void greet() {
        greetSomeone(name);
      }

      @Override
      public void greetSomeone(String someone) {
        name = someone;
        System.out.println("Hello, " + name);
      }
    }

    HelloWorld englishGreeting = new EnglishGreeting();

    // 法语问候 - 匿名内部类实现
    HelloWorld frenchGreeting = new HelloWorld() {
      String name = "tout le monde";

      @Override
      public void greet() {
        greetSomeone(name);
      }

      @Override
      public void greetSomeone(String someone) {
        name = someone;
        System.out.println("Salut, " + name);
      }
    };

    // 西班牙语问候 - 匿名内部类实现
    HelloWorld spanishGreeting = new HelloWorld() {
      String name = "mundo";

      @Override
      public void greet() {
        greetSomeone("mundo");
      }

      @Override
      public void greetSomeone(String someone) {
        name = someone;
        System.out.println("Hola, " + name);
      }
    };

    englishGreeting.greet();
    frenchGreeting.greetSomeone("Fred");
    spanishGreeting.greet();
  }

  public static void main(String... args) {
    new HelloWorldAnonymousClassExample().sayHello();
  }

  interface HelloWorld {
    void greet();

    void greetSomeone(String someone);
  }
}
```

输出结果：

```text
Hello, world
Salut, Fred
Hola, mundo
```

示例 2：匿名内部类中的变量遮蔽

```java hl:6,8,14,16
public class AnonymousVariableShadowExample {
  public int x = 0;

  public void printValue(int x) {
    // 局部变量
    System.out.println("LocalVariable.x = " + x);

    final Runnable runnable = new Runnable() {
      final int x = 1;

      @Override
      public void run() {
        // 匿名内部类的同名成员变量
        System.out.println("AnonymousClass.x = " + this.x);
        // 外部类的同名成员变量
        System.out.println("OuterClass.x = " + AnonymousVariableShadowExample.this.x);
      }
    };

    runnable.run();
  }

  public static void main(String[] args) {
    new AnonymousVariableShadowExample().printValue(23);
  }
}
```

输出结果：

```text
LocalVariable.x = 23
AnonymousClass.x = 1
OuterClass.x = 0
```

## 问题与练习

### 问题

1. 🤔程序 [Problem.java](https://docs.oracle.com/javase/tutorial/java/javaOO/QandE/Problem.java) 无法编译。你需要做什么才能让它编译？为什么？
   🤓删除 `Inner` 类声明前面的 `static`，因为静态内部类不能直接访问外部类的实例字段。请参见 [ProblemSolved.java](https://docs.oracle.com/javase/tutorial/java/javaOO/QandE/ProblemSolved.java)。
2. 使用 `javax.swing` 包中的 `Box` 类的 Java API 文档来帮助你回答以下问题。
    1. Box 类定义了哪个静态嵌套类？`Box.Filler`。
    2. Box 类中定义了哪个内部类？`Box.AccessibleBox`。
    3. Box 类中内部类的超类是什么？`Container.AccessibleAWTContainer`。
    4. Box 类中的哪些嵌套类可以在任何类中使用？`Box.Filler`。
    5. 如何创建 `Box` 类的 `Filler` 类的实例？`new Box.Filler(minDimension, prefDimension, maxDimension);`

### 练习

栗子 1：获取 [Class1.java](https://docs.oracle.com/javase/tutorial/java/javaOO/QandE/Class1.java) 文件，然后编译并运行 `Class1`。输出是什么？

```text
InnerClass1: getString invoked.  
InnerClass1: getAnotherString invoked.
```

栗子 2：以下练习涉及修改 [DataStructure.java](https://docs.oracle.com/javase/tutorial/java/javaOO/examples/DataStructure.java) 类，这个类在[[#成员内部类]] 一节中有讨论。

1. 定义了一个名为 `print()` 的方法，该方法接受一个 `DataStructureIterator` 类型的参数 `iterator`。使用 `EvenIterator` 类的一个实例调用这个方法，以便它执行与 `printEven()` 方法相同的功能。提示：如果你在 `main` 方法中指定了以下语句，它们将无法编译：

	```java
   DataStructure ds = new DataStructure();
   ds.print(new EvenIterator());
	```

   当编译器遇到表达式 `new EvenIterator()` 时，它会生成错误消息 ' 非静态变量 this 不能在静态上下文中引用 '。`EvenIterator` 类是一个内部的非静态类。这意味着你只能在 `DataStructure` 类的实例内部创建 `EvenIterator` 类的实例。你可以在 `DataStructure` 类中定义一个方法，该方法创建并返回一个新的 `EvenIterator` 类的实例。
2. 调用 `print(DataStructureIterator iterator)` 方法，使其打印具有奇数索引值的元素。使用匿名类作为方法的参数，而不是 `DataStructureIterator` 接口的实例。提示：你不能在 `DataStructure` 类之外访问私有成员 `SIZE` 和 `arrayOfInts`，这意味着你不能从 `DataStructure` 类之外定义的匿名类中访问这些私有成员。你可以定义方法来访问私有成员 `SIZE` 和 `arrayOfInts`，然后在你的匿名类中使用这些方法。
3. 定义一个名为 `print` 的方法，该方法接受一个 `Function<Integer, Boolean>` 类型的参数 `iterator`，并执行与 `print(DataStructureIterator iterator)` 相同的功能。使用 lambda 表达式调用这个方法来打印具有偶数索引值的元素。再次使用 lambda 表达式调用这个方法来打印具有奇数索引值的元素。提示：在这个 `print` 方法中，你可以使用 `for` 表达式遍历 `arrayOfInts` 数组中的元素。对于每个索引值，调用 `function.apply` 方法。如果该方法对某个特定索引值返回 `true`，则打印该索引值处的元素。为了调用这个 `print` 方法来打印具有偶数索引值的元素，你可以指定一个实现 `Boolean Function.apply(Integer t)` 方法的 lambda 表达式。这个 lambda 表达式接受一个 `Integer` 参数（索引值），并返回一个布尔值（如果索引值是偶数则返回 `Boolean.TRUE`，否则返回 `Boolean.FALSE`）。
4. 定义两个方法，使得以下语句能够打印具有偶数索引值的元素，然后打印具有奇数索引值的元素：

	```java
   DataStructure ds = new DataStructure()
   // ...
   ds.print(DataStructure::isEvenIndex);
   ds.print(DataStructure::isOddIndex);
	```

> [!tip]
>
> 在 `DataStructure` 类中创建两个名为 `isEvenIndex` 和 `isOddIndex` 的方法，这些方法具有与抽象方法 `Boolean Function<Integer, Boolean>.apply (Integer t)` 相同的参数列表和返回类型。这意味着这些方法接受一个 `Integer` 参数（索引值），并返回一个布尔值。

```java file:"点我查看答案" fold
public class DataStructure {

    // Create an array
    private final static int SIZE = 15;
    private final int[] arrayOfInts = new int[SIZE];

    public DataStructure() {
        // fill the array with ascending integer values
        for (int i = 0; i < SIZE; i++) {
            arrayOfInts[i] = i;
        }
    }

    public int getSize() {
        return SIZE;
    }

    public int get(int index) {
        return arrayOfInts[index];
    }

    public EvenIterator getEvenIterator() {
        return new EvenIterator();
    }

    public void print(java.util.function.Function<Integer, Boolean> iterator) {
        for (int i = 0; i < SIZE; i++) {
            if (iterator.apply(i)) {
                System.out.print(arrayOfInts[i] + " ");
            }
        }
        System.out.println();
    }

    public void print(DataStructureIterator iterator) {
        while (iterator.hasNext()) {
            System.out.print(iterator.next() + " ");
        }
        System.out.println();
    }

    public void printEven() {
        // Print out values of even indices of the array
        DataStructureIterator iterator = this.new EvenIterator();
        while (iterator.hasNext()) {
            System.out.print(iterator.next() + " ");
        }
        System.out.println();
    }

    public static Boolean isEvenIndex(int index) {
        return index % 2 == 0;
    }

    public static Boolean isOddIndex(int index) {
        return index % 2 != 0;
    }

    public static void main(String[] s) {

        // Fill the array with integer values and print out only
        // values of even indices
        DataStructure ds = new DataStructure();
        System.out.println("printEven()");
        ds.printEven();

        System.out.println("print(DataStructureIterator) with getEvenIterator");
        ds.print(ds.getEvenIterator());

        System.out.println("print(DataStructureIterator) with anonymous class, odd indicies");
        ds.print(new DataStructureIterator() {
            private int nextIndex = 1;

            @Override
            public boolean hasNext() {
                return nextIndex <= ds.getSize() - 1;
            }

            @Override
            public Integer next() {
                final int retValue = ds.get(nextIndex);
                nextIndex += 2;
                return retValue;
            }
        });

        System.out.println("print(Function) with lambda expressions");
        ds.print((i) -> i % 2 == 0);
        ds.print(i -> i % 2 != 0);

        System.out.println("print(Function) with method references");
        ds.print(DataStructure::isEvenIndex);
        ds.print(DataStructure::isOddIndex);
    }

    // Inner class implements the DataStructureIterator interface,
    // which extends the Iterator<Integer> interface

    interface DataStructureIterator extends java.util.Iterator<Integer> {
    }

    private class EvenIterator implements DataStructureIterator {

        // Start stepping through the array from the beginning
        private int nextIndex = 0;

        @Override
        public boolean hasNext() {

            // Check if the current element is the last in the array
            return (nextIndex <= SIZE - 1);
        }

        @Override
        public Integer next() {

            // Record a value of an even index of the array
            Integer retValue = arrayOfInts[nextIndex];

            // Get the next even element
            nextIndex += 2;
            return retValue;
        }
    }
}
```
