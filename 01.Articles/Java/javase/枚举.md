---
tags:
  - Java/JavaSE
create_time: 2025/06/17 22:31
update_time: 2025/07/29 19:30
---

## 为什么需要枚举？

### 静态常量的局限

当需要表示一组固定值（如四季）时，常见做法是使用静态常量：

```java
public class Season {
	/** 春 */
	public static final int SPRING = 1;
	/** 夏 */
	public static final int SUMMER = 2;
	/** 秋 */
	public static final int AUTUMN = 3;
	/** 冬 */
	public static final int WINTER = 4;
}
```

使用示例：

```java
System.out.println(Season.SPRING);
System.out.println(Season.SUMMER);
```

我们可能会定义如下方法，根据季节执行对应逻辑：

```java
public static void f(int season) {
  switch (season) {
    case Season.SPRING:
      System.out.println("春天来了");
      break;
    case Season.SUMMER:
      System.out.println("夏天炎热");
      break;
    case Season.AUTUMN:
      System.out.println("秋天凉爽");
      break;
    case Season.WINTER:
      System.out.println("冬天寒冷");
      break;
    default:
      System.out.println("未知季节");
  }
}
```

使用示例：

```java
f(Season.SPRING); // 春天来了
f(3);             // 秋天凉爽
f(5);             // 未知季节
```

这种设计虽然简单，但存在以下问题：

- ❌ **类型不安全**：可传入任意整数；
- ❌ **可读性差**：调用者需记住数字代表的含义；
- ❌ **扩展性差**：无法附加额外属性或行为。

### 自定义不可变类：枚举雏形

为解决静态常量的缺陷，可将常量封装为**不可变类**：**构造方法私有化**、**类声明为 `final` 以防被继承**，并**在类内部定义有限实例**：

```java hl:1,11
public final class Season {
	/** 春 */
	public static final Season SPRING = new Season();
	/** 夏 */
	public static final Season SUMMER = new Season();
	/** 秋 */
	public static final Season AUTUMN = new Season();
	/** 冬 */
	public static final Season WINTER = new Season();
	
	private Season() {}
}
```

方法参数可通过类型约束，提升安全性：

```java
public static void f(Season season) {
	// 只接受 Season 类型
}

public static void main(String[] args) {
  f(Season.SPRING);   // ✅ 合法
  f(Season.SUMMER);   // ✅ 合法
  f("SUMMER");        // ❌ 编译错误
  f(1);               // ❌ 编译错误
}
```

恭喜你，已经 "手动实现" 了一个枚举！这种设计已具备枚举的核心特性：
- ✅ **类型安全**
- ✅ **有限实例**
- ✅ **禁止扩展**

## 基本语法

枚举（`Enum`）是 Java 中一种特殊的类，用于**表示一组固定的常量值**，如四季、月份、星期或方向等。

使用 `enum` 关键字定义，语法格式如下：

```java
[修饰符] enum 枚举名 {
  枚举项1, 枚举项2, ...;

  // 其他成员（字段、构造方法、方法等）
}
```

> [!note]
> **枚举项必须声明在类的最前面，每项之间用逗号 `,` 分隔**。若后续还有成员，最后一个枚举项后面必须加分号 `;`，否则可省略。

特性：
- 每个枚举项都是枚举类中**唯一且固定的实例**，在**类加载时自动创建，默认由 `public static final` 修饰**，本质上是一个**不可变的常量对象**。
- 构造方法**必须是 `private`**，即使未显式声明，也会**隐式生成**，因此**无法在类外部通过 `new` 创建实例**。
- 所有枚举类都**隐式继承自 `java.lang.Enum`**，因此**不能再继承其他类**，但**可以实现接口**。
- 枚举类本身隐式**声明为 `final`，不可被继承**。
- 除枚举项外，枚举类还可定义**字段、构造方法、实例方法**等成员，功能与普通类基本一致。

## 底层原理

可通过反编译命令 `javap Season.class` 查看枚举在字节码中的实际结构：

```java hl:2
Compiled from "Season.java"
public final class fun.xiaorang.study.javase._enum.Season extends java.lang.Enum<fun.xiaorang.study.javase._enum.Season> {
  public static final fun.xiaorang.study.javase._enum.Season SPRING;
  public static final fun.xiaorang.study.javase._enum.Season SUMMER;
  public static final fun.xiaorang.study.javase._enum.Season AUTUMN;
  public static final fun.xiaorang.study.javase._enum.Season WINTER;
  
  public static fun.xiaorang.study.javase._enum.Season[] values();
  public static fun.xiaorang.study.javase._enum.Season valueOf(java.lang.String);
}
```

从反编译结果可以看出：
- 每个枚举项本质上是由 `public static final` 修饰的枚举类实例；
- 枚举类继承自 `java.lang.Enum`，因此不能再继承其他类；
- 枚举类被声明为 `final`，因此无法被继承。

## 进阶用法

### 添加字段和构造方法

枚举类可以像普通类一样定义字段、构造器和方法。构造方法必须为 `private`（或省略不写），并由枚举项在定义时调用：

```java
public enum Season {
  SPRING("春", 1),
  SUMMER("夏", 2),
  AUTUMN("秋", 3),
  WINTER("冬", 4);

  private final String name;
  private final int code;

  Season(String name, int code) {
    this.name = name;
    this.code = code;
  }

  public String getName() {
    return name;
  }

  public int getCode() {
    return code;
  }
}
```

使用示例：

```java
System.out.println(Season.SPRING.getName()); // 春
System.out.println(Season.SUMMER.getCode()); // 2
```

### 添加自定义方法

可以为枚举类添加静态方法，根据某个属性值查找对应的枚举项，实现由 "值 → 枚举" 的映射功能。

```java
public static Season fromCode(int code) {
  for (Season s : Season.values()) {
    if (s.code == code) return s;
  }
  throw new IllegalArgumentException("Invalid code: " + code);
}
```

使用示例：

```java
Season season = Season.fromCode(2); // SUMMER
```

可以在枚举类中定义抽象方法，并由每个枚举项提供各自的具体实现。

```java hl:24
public enum Calculator {
  ADD {
    public int operate(int a, int b) {
      return a + b;
    }
  },
  SUB {
    public int operate(int a, int b) {
      return a - b;
    }
  },
  MUL {
    public int operate(int a, int b) {
      return a * b;
    }
  },
  DIV {
    public int operate(int a, int b) {
      if (b == 0) throw new ArithmeticException("除数不能为0");
      return a / b;
    }
  };

  public abstract int operate(int a, int b);
}
```

使用示例：

```java
int result = Calculator.MUL.operate(3, 4); // 12
```

### 实现接口

枚举类可以实现接口，由每个枚举项自定义实现逻辑，常用于配合[[策略模式]]：

```java
public interface Action {
  void execute();
}

public enum Command implements Action {
  START {
    public void execute() {
      System.out.println("启动");
    }
  },
  STOP {
    public void execute() {
      System.out.println("关闭");
    }
  },
  RESTART {
    public void execute() {
      System.out.println("重启");
    }
  }
}
```

使用示例：

```java
Command.START.execute(); // 启动
Command.STOP.execute(); // 关闭
```

## 典型应用场景

### 状态流转（状态机）

通过定义抽象方法并由枚举项实现，可以实现状态流转：

```java
public enum OrderState {
  CREATED {
    @Override
    public OrderState next() {
      return PAID;
    }
  },
  PAID {
    @Override
    public OrderState next() {
      return SHIPPED;
    }
  },
  SHIPPED {
    @Override
    public OrderState next() {
      return COMPLETED;
    }
  },
  COMPLETED {
    @Override
    public OrderState next() {
      return this; // 结束状态不再流转
    }
  };

  public abstract OrderState next();
}
```

使用示例：

```java
OrderState state = OrderState.CREATED;
state = state.next(); // PAID
state = state.next(); // SHIPPED
```

### 行为策略（任务类型）

枚举实现接口，为每个枚举项定义不同行为，常用于任务处理或事件响应：

```java
public interface TaskHandler {
  void execute();
}

public enum TaskType implements TaskHandler {
  IMPORT {
    public void execute() {
      System.out.println("导入数据");
    }
  },
  EXPORT {
    public void execute() {
      System.out.println("导出数据");
    }
  }
}
```

使用示例：

```java
TaskType task = TaskType.EXPORT;
task.execute(); // 导出数据
```

### 枚举工厂映射（策略模式）

使用 `EnumMap` 将枚举与对应策略实现关联，快速实现基于类型的策略分发：

定义枚举类型：

```java
public enum LoginType {
  PASSWORD, SMS, OAUTH;
}
```

策略接口与具体实现：

```java
public interface LoginStrategy {
  void login(String username);
}
```

```java
public class PasswordLogin implements LoginStrategy {
  public void login(String username) {
    System.out.println("密码登录：" + username);
  }
}

public class SmsLogin implements LoginStrategy {
  public void login(String username) {
    System.out.println("短信验证码登录：" + username);
  }
}

public class OAuthLogin implements LoginStrategy {
  public void login(String username) {
    System.out.println("第三方授权登录：" + username);
  }
}
```

策略工厂类：

```java
public class LoginStrategyFactory {
  private static final Map<LoginType, LoginStrategy> STRATEGY_MAP = new EnumMap<>(LoginType.class);

  static {
    STRATEGY_MAP.put(LoginType.PASSWORD, new PasswordLogin());
    STRATEGY_MAP.put(LoginType.SMS, new SmsLogin());
    STRATEGY_MAP.put(LoginType.OAUTH, new OAuthLogin());
  }

  public static LoginStrategy get(LoginType type) {
    return STRATEGY_MAP.get(type);
  }
}
```

使用示例：

```java
LoginStrategy strategy = LoginStrategyFactory.get(LoginType.SMS);
strategy.login("xiaojiumao");
```
