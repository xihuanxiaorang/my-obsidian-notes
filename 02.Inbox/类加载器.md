---
tags:
  - Java/JavaSE
create_time: 2025/08/04 12:19
update_time: 2025/08/07 19:20
---

## 定义

类加载器（ClassLoader）是 Java 虚拟机中负责将 `.class` 字节码文件加载到内存，并将其转换为 JVM 可执行的 `Class` 对象的组件。

## 类加载时机

Java 使用动态加载（Dynamic Loading）机制，类只有在真正被使用时才会被加载，并且每个类只会被加载一次。

类加载的常见触发时机包括：
1. 创建类的实例（对象）；
2. 访问类的静态成员（变量或方法）；
3. 创建子类实例（对象）时，父类会先被加载；
4. 访问子类的静态成员（变量或方法）时，父类会先被加载；
5. 通过[[反射]]方式访问类时。

^classload-timing

## 类加载过程

Java 中类的加载过程分为三个阶段，共包含五个核心步骤：

1. 加载（Loading）：该阶段负责将类的 `.class` 字节码从外部介质加载进 JVM，并构建相应的内存结构。
	- 获取字节流：根据类的全限定名，从文件系统、JAR 包或网络中获取 `.class` 文件的二进制字节流；
	- 解析字节流为类元信息：将字节流解析为 JVM 方法区（或元空间）中的类元数据结构，用于描述类的字段、方法、继承关系等；
	- 创建 `Class` 对象：在堆中创建对应的 `Class` 对象，，供程序访问类的元信息。
2. 链接（Linking）：该阶段负责对类进行校验、内存准备以及符号引用解析。
	1. 验证（Verification）：确保 `.class` 文件字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全；
	2. 准备（Preparation）：为类的静态成员变量分配内存并设置默认值（如：`0`、`null`、`false` 等）；
	3. 解析（Resolution）：将常量池中的符号引用（如：类名、字段名、方法名等）解析为直接引用（内存地址或偏移）。
3. 初始化（Initialization）：该阶段负责执行类中定义的初始化逻辑。
	- 执行类的 `<clinit>()` 方法，即静态初始化方法，该方法由 JVM 自动合成并调用，用于按照定义顺序依次初始化静态变量并执行静态代码块；
	- 初始化过程是线程安全的，JVM 会保证一个类仅被初始化一次。

## 分类

Java 中的类加载器主要分为以下三种：
- 启动类加载器（Bootstrap ClassLoader）：
	- JVM 内置的类加载器，使用 C/C++ 实现，是所有类加载器的顶层父加载器（通过组合而非继承方式实现）；
	- 负责加载 Java 核心类库中的类，如 `java.lang.*`、`java.util.*` 等；
	- 加载路径通常为 `$JAVA_HOME/lib` 或由启动参数 `-Xbootclasspath` 指定；
	- 不继承自 `java.lang.ClassLoader`，因此无法在 Java 代码中直接访问或操作。
- 平台类加载器（Platform/Ext ClassLoader）：
	- 负责加载平台相关的扩展类库，如模块化后的 JDK 内部模块或旧版的 `ext` 扩展目录（如 `jre/lib/ext`）下的类；
	- 在 JDK 9 之后替代了原先的扩展类加载器（`ExtClassLoader`），并支持模块化系统。
- 系统类加载器（System/App ClassLoader）：
	- 负责加载应用程序类路径（`classpath`）下的类，包括用户编写的 Java 类、第三方库等；
	- 默认加载路径包括启动参数 `-cp` 或 `-classpath` 指定的目录及 JAR 包。

## 双亲委派模型

Java 的类加载器体系遵循双亲委派模型：当类加载器加载某个类时，会先将请求逐级向上委托给父加载器，直至顶层的启动类加载器。若父加载器无法完成加载任务，委托将逐级回退，由下层加载器依次尝试加载，直至成功或最终抛出 `ClassNotFoundException`。

加载流程：
1. 系统类加载器（App ClassLoader）收到类加载请求；
2. 首先将请求委托给其父加载器，即平台类加载器（Platform ClassLoader）；
3. 平台类加载器继续将请求向上委托给启动类加载器（Bootstrap ClassLoader）；
4. 启动类加载器尝试加载核心类库中的类（位于 `$JAVA_HOME/lib` 路径下的类）；
5. 若启动类加载器无法加载，委托回退，由平台类加载器尝试加载；
6. 若平台类加载器也加载失败，委托继续回退，由系统类加载器尝试加载；
7. 若所有加载器均无法加载该类，则抛出 `ClassNotFoundException`。

优点：
- 避免重复加载：类只会由最合适的类加载器加载一次，避免同一个类在多个加载器中被重复加载；
- 保证核心类库安全性：确保用户代码无法伪造或替换核心类库中的类，如 `java.lang.String`；
- 类隔离机制：不同类加载器加载的类互相隔离，有利于实现模块化、插件化、热部署等复杂应用场景。

代码实现：

```java
public Class<?> loadClass(String name) throws ClassNotFoundException {
  return loadClass(name, false);
}

protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
  // 1. 检查该类是否已经被加载过
  Class<?> c = findLoadedClass(name);

  // 2. 如果未加载，则尝试通过父类加载器或启动类加载器加载
  if (c == null) {
    try {
      if (parent != null) {
        // 有父加载器，优先委托父加载器加载（双亲委派）
        c = parent.loadClass(name, false);
      } else {
        // 无父加载器时，通过调用 JVM 提供的本地方法 findBootstrapClass0() 检查是否由启动类加载器加载该类
        c = findBootstrapClass0(name);
      }
    } catch (ClassNotFoundException e) {
      // 3. 如果父加载器和启动类加载器都无法加载，则由当前加载器尝试加载
      c = findClass(name);
    }
  }

  // 4. 如果指定 resolve 为 true，则对类进行链接（验证、准备、解析）
  if (resolve) {
    resolveClass(c);
  }

  return c;
}
```

## 获取方式

1. 获取当前类的类加载器

	```java
	ClassLoader classLoader = YourClass.class.getClassLoader();
	```

	- 返回加载 `YourClass` 类的类加载器；
	- 若该类由启动类加载器加载，则返回 `null`。

2. 获取系统类加载器

	```java
	ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
	```

	- 用于加载用户类路径（`classpath`）下的类；
	- 常用于获取应用程序中的资源文件，可结合 `getResourceAsStream()` 等方法使用。

3. 通过类加载器实例获取其加载器

	```java
	final ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); // jdk.internal.loader.ClassLoaders$AppClassLoader@63947c6b
	final ClassLoader platformClassLoader = systemClassLoader.getParent(); // jdk.internal.loader.ClassLoaders$PlatformClassLoader@5b6f7412
	final ClassLoader bootstrapClassLoader = platformClassLoader.getParent(); // null
	```

	- 可通过 `.getParent()` 向上追溯类加载器层级；
	- 若返回 `null`，表示已到达最顶层的启动类加载器，它由 JVM 使用 C/C++ 实现，并不属于 Java 层面的 `ClassLoader` 类体系。

4. 获取当前线程的上下文类加载器

	```java
	ClassLoader cl = Thread.currentThread().getContextClassLoader();
	```

	- 常用于 SPI（Service Provider Interface）机制；
	- 可动态切换类加载上下文，适用于模块化、插件化等灵活资源加载场景；
	- 相比默认类加载器，更适合由第三方组件或容器主导的类加载流程（如 JDBC、JNDI、Spring、OSGi 等）。

## 使用场景

示例 1：使用 `getResourceAsStream()` 方法加载资源文件。

```properties file:db.properties
# 数据库驱动类  
jdbc.driverClassName=com.mysql.cj.jdbc.Driver  
# 数据库连接 
URLjdbc.url=jdbc:mysql://localhost:3306/your_database_name?useSSL=false&serverTimezone=UTC&characterEncoding=UTF-8  
# 数据库用户名  
jdbc.username=root  
# 数据库密码  
jdbc.password=your_password
```

Java 加载配置示例：

```java
public class Test {  
  public static void main(String[] args) {  
    final ClassLoader classLoader = Test.class.getClassLoader();  
    try (InputStream inputStream = classLoader.getResourceAsStream("db.properties")) {  
      Properties properties = new Properties();  
      properties.load(inputStream);  
      System.out.println(properties);  
    } catch (IOException e) {  
      throw new RuntimeException("Failed to load db.properties", e);  
    }  
  }  
}
```

- `getResourceAsStream(String name)`
	- 作用：通过类加载器加载类路径（classpath）下的资源文件；
	- 返回值：`InputStream`，可用于读取文件内容；
	- 常见用途：可用于加载，
	    - `.properties` 配置文件（如 Spring Boot 中的 `application.properties`）；
	    - XML 配置（如 MyBatis 的 `mybatis-config.xml`）；
	    - 模板文件（如 Thymeleaf/Freemarker 模板）；
	    - 静态资源（如 JSON、TXT、CSV 文件等）；
