---
tags:
  - Java/JavaSE
create_time: 2025/08/04 12:19
update_time: 2025/08/09 23:42
---

## 定义

类加载器（ClassLoader）是 Java 虚拟机中负责将 `.class` 字节码文件加载到内存，并将其转换为 JVM 可执行的 `Class` 对象的组件。

## 类加载时机

在 JVM 中，类采用按需加载（Lazy Loading）机制：仅在首次使用时才会加载，且在整个运行周期内只会被加载一次。

常见触发时机包括：
1. 创建类的实例（对象）；
2. 访问类的静态成员（变量或方法）；
3. 创建子类实例（对象）时，父类会先被加载；
4. 访问子类的静态成员（变量或方法）时，父类会先被加载；
5. 通过[[反射]]方式访问类；
6. 显式调用 `ClassLoader` 的 `loadClass()` 方法加载一个类。

^classload-timing

## 类加载流程

1. 加载（Loading）：该阶段负责将类的 `.class` 字节码从外部介质加载进 JVM，并构建相应的内存结构。
	- 获取字节流：根据类的全限定名，从文件系统、JAR 包或网络等位置获取 `.class` 文件的二进制字节流；
	- 解析为类的元数据信息：将字节流解析为 JVM 方法区中类的元数据信息（描述类的字段、方法、继承关系等）；
	- 创建 `Class` 对象：在堆中创建对应的 `Class` 对象，作为访问类的元数据信息的入口。
2. 链接（Linking）：该阶段负责对类进行校验、内存准备以及符号引用解析。
	1. 验证（Verification）：确保 `.class` 字节码文件中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全；
	2. 准备（Preparation）：在方法区中为类的静态成员变量分配内存并设置默认值（如：`0`、`null`、`false` 等）；
	3. 解析（Resolution）：将常量池中的[[#^ce6a3e|符号引用]]替换为[[#^70fa60|直接引用]]。
3. 初始化（Initialization）：该阶段负责执行类中定义的初始化逻辑。
	- 执行类的 `<clinit>()` 方法（即静态初始化方法，由 JVM 自动合成并调用），用于按照定义顺序依次执行静态变量初始化和[[代码块#静态代码块|静态代码块]]；
	- 初始化过程是线程安全的，JVM 保证一个类仅会初始化一次。
4. 卸载（Unloading）：
	- 一个类需满足以下条件才会被卸载：
		1. 该类的所有实例已被 GC 回收；
		2. 加载该类的类加载器已被回收；
	- 类的卸载开销较大，不会频繁发生，通常只在内存紧张时由 JVM 触发。

> [!question] 符号引用
> - 在编译期生成并存储于 `.class` 文件中，是一种动态的、未确定的引用；
> - 通过符号（如类名、方法名、字段名）描述所引用对象的信息，与实际内存地址无关；
> - 相同的符号引用在不同上下文中可能解析为不同的直接引用，例如多态调用时，不同实例会将同一方法名解析为不同的内存地址。

^ce6a3e

> [!question] 直接引用
> - 一种确定的引用，直接指向对象的内存地址（例如 `0x1001`）；
> - 在类加载的解析阶段，符号引用会被替换为直接引用，从而在运行时可以直接定位目标对象或方法。

^70fa60

## 分类

Java 中的类加载器主要分为以下四种：
- 启动类加载器（Bootstrap ClassLoader）：
	- JVM 内置的类加载器，使用 C/C++ 实现，是所有类加载器的顶层父加载器；
	- 负责加载 Java 核心类库中的类，如 `java.lang.*`、`java.util.*` 等；
	- 加载路径通常为 `$JAVA_HOME/lib` 或由启动参数 `-Xbootclasspath` 指定；
	- 未继承自 `java.lang.ClassLoader`，因此无法在 Java 代码中直接访问或操作。
- 平台类加载器（Platform ClassLoader）：
	- 负责加载平台相关的类库，如 JDK 内部模块、SPI 服务接口等；
	- JDK 9 引入，用于替代旧版的扩展类加载器（Extension ClassLoader，负责加载 `jre/lib/ext` 下的类）；
	- 可通过 `ClassLoader.getPlatformClassLoader()` 获取实例对象。
- 系统类加载器（System/Application ClassLoader）：
	- 负责加载应用程序类路径（classpath）下的类，包括用户编写的 Java 类和第三方依赖；
	- 加载路径可由启动参数 `-cp` / `-classpath` 指定，也可通过 JAR 包的 `META-INF/MANIFEST.MF` 中的 `Class-Path` 属性追加指定；
	- 可通过 `ClassLoader.getSystemClassLoader()` 获取实例对象。
- 自定义类加载（User ClassLoader）：
	- 可通过继承 `java.lang.ClassLoader` 并重写 `findClass()` 方法实现；
	- 常用于模块热加载、类文件加/解密、从网络或数据库动态加载类等场景；
	- 通常仍遵循[[#双亲委派模型]]，但可根据需要打破该机制以实现特殊加载策略。

类加载器之间的层级关系：
![[类加载器之间的层级关系|600]]

> [!tip]
> 类加载器之间的父子关系是通过组合而非继承方式实现的，每个子类加载器都持有一个父类加载器的引用。

## 双亲委派模型

基于类加载器之间的层级关系，双亲委派模型是指：当一个类加载器接收到类加载请求时，会先将请求委派给其父类加载器处理；若父类加载器无法完成加载任务，请求会逐级回退，由当前类加载器及其子类加载器依次尝试加载，直至加载成功或最终抛出 `ClassNotFoundException` 异常。

一个类的加载流程：
1. 系统类加载器（System/Application ClassLoader）收到类加载请求；
2. 先将请求委托给其父类加载器 - 平台类加载器（Platform ClassLoader）；
3. 平台类加载器继续将请求向上委托给其父类加载器 - 启动类加载器（Bootstrap ClassLoader）；
4. 启动类加载器尝试加载核心类库中的类（位于 `$JAVA_HOME/lib` 路径下的类）；
5. 若启动类加载器加载失败，则回退至平台类加载器尝试加载；
6. 若平台类加载器也加载失败，则继续回退至系统类加载器尝试加载；
7. 若所有加载器均加载失败，则抛出 `ClassNotFoundException` 异常。

优点：
- 避免重复加载：类只会由最合适的类加载器加载一次，避免同一个类在多个加载器中被重复加载；
- 保证核心类库安全性：确保用户代码无法伪造或替换核心类库中的类，如 `java.lang.String`；
- 类隔离机制：不同类加载器加载的类互相隔离，有利于实现模块化、插件化、热部署等复杂应用场景。

代码实现：

```java
public Class<?> loadClass(String name) throws ClassNotFoundException {
  return loadClass(name, false);
}

protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
  // 1. 检查该类是否已经被加载过
  Class<?> c = findLoadedClass(name);

  // 2. 如果未加载，则尝试通过父类加载器或启动类加载器加载
  if (c == null) {
    try {
      if (parent != null) {
        // 有父加载器，优先委托父加载器加载（双亲委派）
        c = parent.loadClass(name, false);
      } else {
        // 无父加载器时，通过调用 JVM 提供的本地方法 findBootstrapClass0() 检查是否由启动类加载器加载该类
        c = findBootstrapClass0(name);
      }
    } catch (ClassNotFoundException e) {
      // 3. 如果父加载器和启动类加载器都无法加载，则由当前加载器尝试加载
      c = findClass(name);
    }
  }

  // 4. 如果指定 resolve 为 true，则对类进行链接（验证、准备、解析）
  if (resolve) {
    resolveClass(c);
  }

  return c;
}
```

## 获取方式

1. 获取当前类的类加载器

	```java
	ClassLoader classLoader = YourClass.class.getClassLoader();
	```

	- 返回加载 `YourClass` 类的类加载器；
	- 若该类由启动类加载器加载，则返回 `null`。

2. 获取系统类加载器

	```java
	ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
	```

	- 用于加载用户类路径（`classpath`）下的类；
	- 常用于获取应用程序中的资源文件，可结合 `getResourceAsStream()` 等方法使用。

3. 通过类加载器实例获取其加载器

	```java
	final ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); // jdk.internal.loader.ClassLoaders$AppClassLoader@63947c6b
	final ClassLoader platformClassLoader = systemClassLoader.getParent(); // jdk.internal.loader.ClassLoaders$PlatformClassLoader@5b6f7412
	final ClassLoader bootstrapClassLoader = platformClassLoader.getParent(); // null
	```

	- 可通过 `.getParent()` 向上追溯类加载器层级；
	- 若返回 `null`，表示已到达最顶层的启动类加载器，它由 JVM 使用 C/C++ 实现，并不属于 Java 层面的 `ClassLoader` 类体系。

4. 获取当前线程的上下文类加载器

	```java
	ClassLoader cl = Thread.currentThread().getContextClassLoader();
	```

	- 常用于 SPI（Service Provider Interface）机制；
	- 可动态切换类加载上下文，适用于模块化、插件化等灵活资源加载场景；
	- 相比默认类加载器，更适合由第三方组件或容器主导的类加载流程（如 JDBC、JNDI、Spring、OSGi 等）。

## 使用场景

示例 1：使用 `getResourceAsStream()` 方法加载资源文件。

```properties file:db.properties
# 数据库驱动类  
jdbc.driverClassName=com.mysql.cj.jdbc.Driver  
# 数据库连接 
URLjdbc.url=jdbc:mysql://localhost:3306/your_database_name?useSSL=false&serverTimezone=UTC&characterEncoding=UTF-8  
# 数据库用户名  
jdbc.username=root  
# 数据库密码  
jdbc.password=your_password
```

Java 加载配置示例：

```java
public class Test {  
  public static void main(String[] args) {  
    final ClassLoader classLoader = Test.class.getClassLoader();  
    try (InputStream inputStream = classLoader.getResourceAsStream("db.properties")) {  
      Properties properties = new Properties();  
      properties.load(inputStream);  
      System.out.println(properties);  
    } catch (IOException e) {  
      throw new RuntimeException("Failed to load db.properties", e);  
    }  
  }  
}
```

- `getResourceAsStream(String name)`
	- 作用：通过类加载器加载类路径（classpath）下的资源文件；
	- 返回值：`InputStream`，可用于读取文件内容；
	- 常见用途：可用于加载，
	    - `.properties` 配置文件（如 Spring Boot 中的 `application.properties`）；
	    - XML 配置（如 MyBatis 的 `mybatis-config.xml`）；
	    - 模板文件（如 Thymeleaf/Freemarker 模板）；
	    - 静态资源（如 JSON、TXT、CSV 文件等）；
